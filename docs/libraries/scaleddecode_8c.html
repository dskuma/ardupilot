<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>APM:Libraries: libraries/AP_PiccoloCAN/piccolo_protocol/scaleddecode.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">APM:Libraries
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_bc0718b08fb2015b8e59c47b2805f60c.html">libraries</a></li><li class="navelem"><a class="el" href="dir_7637aab171c7d22504bb7ef521343e9a.html">AP_PiccoloCAN</a></li><li class="navelem"><a class="el" href="dir_5f1dd6f801f133a0a82680552c5c93fc.html">piccolo_protocol</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scaleddecode.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="scaleddecode_8h_source.html">scaleddecode.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fielddecode_8h_source.html">fielddecode.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for scaleddecode.c:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c__incl.svg" width="267" height="198"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<p><a href="scaleddecode_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4c8382ef91a6ab1e4df1eadf26bc756d" id="r_a4c8382ef91a6ab1e4df1eadf26bc756d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c8382ef91a6ab1e4df1eadf26bc756d">float32ScaledFromBitfield</a> (unsigned int <a class="el" href="AP__JSON_8cpp.html#a37700c57263ada4716d7dbbc43089a24">value</a>, float min, float invscaler)</td></tr>
<tr class="memdesc:a4c8382ef91a6ab1e4df1eadf26bc756d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a float using inverse floating point scaling from the base integer type used for bitfields.  <br /></td></tr>
<tr class="separator:a4c8382ef91a6ab1e4df1eadf26bc756d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1449e8c64eaf763ebe0922321c33b1" id="r_a4d1449e8c64eaf763ebe0922321c33b1"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d1449e8c64eaf763ebe0922321c33b1">float32ScaledFrom4UnsignedBeBytes</a> (const uint8_t *bytes, int *index, float min, float invscaler)</td></tr>
<tr class="memdesc:a4d1449e8c64eaf763ebe0922321c33b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a float from a byte stream by inverse floating point scaling from 4 unsigned bytes in big endian order.  <br /></td></tr>
<tr class="separator:a4d1449e8c64eaf763ebe0922321c33b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77105738ce49df0481e5a48ec9f19bc3" id="r_a77105738ce49df0481e5a48ec9f19bc3"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77105738ce49df0481e5a48ec9f19bc3">float32ScaledFrom4UnsignedLeBytes</a> (const uint8_t *bytes, int *index, float min, float invscaler)</td></tr>
<tr class="memdesc:a77105738ce49df0481e5a48ec9f19bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a float from a byte stream by inverse floating point scaling from 4 unsigned bytes in little endian order.  <br /></td></tr>
<tr class="separator:a77105738ce49df0481e5a48ec9f19bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da83420a58598168e022bfe97fed71c" id="r_a1da83420a58598168e022bfe97fed71c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1da83420a58598168e022bfe97fed71c">float32ScaledFrom4SignedBeBytes</a> (const uint8_t *bytes, int *index, float invscaler)</td></tr>
<tr class="memdesc:a1da83420a58598168e022bfe97fed71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a float from a byte stream by inverse floating point scaling from 4 signed bytes in big endian order.  <br /></td></tr>
<tr class="separator:a1da83420a58598168e022bfe97fed71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae922f64ce0cff6ba036eff42f936814a" id="r_ae922f64ce0cff6ba036eff42f936814a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae922f64ce0cff6ba036eff42f936814a">float32ScaledFrom4SignedLeBytes</a> (const uint8_t *bytes, int *index, float invscaler)</td></tr>
<tr class="memdesc:ae922f64ce0cff6ba036eff42f936814a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a float from a byte stream by inverse floating point scaling from 4 signed bytes in little endian order.  <br /></td></tr>
<tr class="separator:ae922f64ce0cff6ba036eff42f936814a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6236aa5906391280a0dd2a71c41314a1" id="r_a6236aa5906391280a0dd2a71c41314a1"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6236aa5906391280a0dd2a71c41314a1">float32ScaledFrom3UnsignedBeBytes</a> (const uint8_t *bytes, int *index, float min, float invscaler)</td></tr>
<tr class="memdesc:a6236aa5906391280a0dd2a71c41314a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a float from a byte stream by inverse floating point scaling from 3 unsigned bytes in big endian order.  <br /></td></tr>
<tr class="separator:a6236aa5906391280a0dd2a71c41314a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1346abe203aeb41c42d843c551210afe" id="r_a1346abe203aeb41c42d843c551210afe"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1346abe203aeb41c42d843c551210afe">float32ScaledFrom3UnsignedLeBytes</a> (const uint8_t *bytes, int *index, float min, float invscaler)</td></tr>
<tr class="memdesc:a1346abe203aeb41c42d843c551210afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a float from a byte stream by inverse floating point scaling from 3 unsigned bytes in little endian order.  <br /></td></tr>
<tr class="separator:a1346abe203aeb41c42d843c551210afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a6d774fa88d2ec1f587637d322419b" id="r_a72a6d774fa88d2ec1f587637d322419b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72a6d774fa88d2ec1f587637d322419b">float32ScaledFrom3SignedBeBytes</a> (const uint8_t *bytes, int *index, float invscaler)</td></tr>
<tr class="memdesc:a72a6d774fa88d2ec1f587637d322419b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a float from a byte stream by inverse floating point scaling from 3 signed bytes in big endian order.  <br /></td></tr>
<tr class="separator:a72a6d774fa88d2ec1f587637d322419b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f26f6ee50b2a38bbcae24e109f9508" id="r_a80f26f6ee50b2a38bbcae24e109f9508"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80f26f6ee50b2a38bbcae24e109f9508">float32ScaledFrom3SignedLeBytes</a> (const uint8_t *bytes, int *index, float invscaler)</td></tr>
<tr class="memdesc:a80f26f6ee50b2a38bbcae24e109f9508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a float from a byte stream by inverse floating point scaling from 3 signed bytes in little endian order.  <br /></td></tr>
<tr class="separator:a80f26f6ee50b2a38bbcae24e109f9508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfa1ff201520a07e1e62b437bd7d5a2" id="r_a8cfa1ff201520a07e1e62b437bd7d5a2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cfa1ff201520a07e1e62b437bd7d5a2">float32ScaledFrom2UnsignedBeBytes</a> (const uint8_t *bytes, int *index, float min, float invscaler)</td></tr>
<tr class="memdesc:a8cfa1ff201520a07e1e62b437bd7d5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a float from a byte stream by inverse floating point scaling from 2 unsigned bytes in big endian order.  <br /></td></tr>
<tr class="separator:a8cfa1ff201520a07e1e62b437bd7d5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca8dee3b750d6cf5c1687acc3ccf1c6" id="r_aaca8dee3b750d6cf5c1687acc3ccf1c6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaca8dee3b750d6cf5c1687acc3ccf1c6">float32ScaledFrom2UnsignedLeBytes</a> (const uint8_t *bytes, int *index, float min, float invscaler)</td></tr>
<tr class="memdesc:aaca8dee3b750d6cf5c1687acc3ccf1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a float from a byte stream by inverse floating point scaling from 2 unsigned bytes in little endian order.  <br /></td></tr>
<tr class="separator:aaca8dee3b750d6cf5c1687acc3ccf1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7856923a13cbba11d5ca6c496c6eb2c" id="r_ad7856923a13cbba11d5ca6c496c6eb2c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7856923a13cbba11d5ca6c496c6eb2c">float32ScaledFrom2SignedBeBytes</a> (const uint8_t *bytes, int *index, float invscaler)</td></tr>
<tr class="memdesc:ad7856923a13cbba11d5ca6c496c6eb2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a float from a byte stream by inverse floating point scaling from 2 signed bytes in big endian order.  <br /></td></tr>
<tr class="separator:ad7856923a13cbba11d5ca6c496c6eb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4572085e1aee5acd3d9d7d4a77e01d4e" id="r_a4572085e1aee5acd3d9d7d4a77e01d4e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4572085e1aee5acd3d9d7d4a77e01d4e">float32ScaledFrom2SignedLeBytes</a> (const uint8_t *bytes, int *index, float invscaler)</td></tr>
<tr class="memdesc:a4572085e1aee5acd3d9d7d4a77e01d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a float from a byte stream by inverse floating point scaling from 2 signed bytes in little endian order.  <br /></td></tr>
<tr class="separator:a4572085e1aee5acd3d9d7d4a77e01d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fb6f8e62c85655cba5722519e3b530" id="r_ae7fb6f8e62c85655cba5722519e3b530"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7fb6f8e62c85655cba5722519e3b530">float32ScaledFrom1UnsignedBytes</a> (const uint8_t *bytes, int *index, float min, float invscaler)</td></tr>
<tr class="memdesc:ae7fb6f8e62c85655cba5722519e3b530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a float from a byte stream by inverse floating point scaling from 1 unsigned byte.  <br /></td></tr>
<tr class="separator:ae7fb6f8e62c85655cba5722519e3b530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f32237ad49a8c1f657bfc2f4067d32" id="r_af2f32237ad49a8c1f657bfc2f4067d32"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2f32237ad49a8c1f657bfc2f4067d32">float32ScaledFrom1SignedBytes</a> (const uint8_t *bytes, int *index, float invscaler)</td></tr>
<tr class="memdesc:af2f32237ad49a8c1f657bfc2f4067d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a float from a byte stream by inverse floating point scaling from 1 signed byte.  <br /></td></tr>
<tr class="separator:af2f32237ad49a8c1f657bfc2f4067d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45b206060ed5c6aef8c86e240f548a9" id="r_ad45b206060ed5c6aef8c86e240f548a9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad45b206060ed5c6aef8c86e240f548a9">uint32ScaledFromBitfield</a> (unsigned int <a class="el" href="AP__JSON_8cpp.html#a37700c57263ada4716d7dbbc43089a24">value</a>, int32_t min, uint32_t divisor)</td></tr>
<tr class="memdesc:ad45b206060ed5c6aef8c86e240f548a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a uint32_t using inverse integer scaling from the base integer type used for bitfields.  <br /></td></tr>
<tr class="separator:ad45b206060ed5c6aef8c86e240f548a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c44296e43e0542644aef57445d1684" id="r_af1c44296e43e0542644aef57445d1684"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1c44296e43e0542644aef57445d1684">uint32ScaledFrom4UnsignedBeBytes</a> (const uint8_t *bytes, int *index, int32_t min, uint32_t divisor)</td></tr>
<tr class="memdesc:af1c44296e43e0542644aef57445d1684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint32_t from a byte stream by inverse integer scaling from 4 unsigned bytes in big endian order.  <br /></td></tr>
<tr class="separator:af1c44296e43e0542644aef57445d1684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd01e92764da7f5a2169e952f5fbd85e" id="r_abd01e92764da7f5a2169e952f5fbd85e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd01e92764da7f5a2169e952f5fbd85e">uint32ScaledFrom4UnsignedLeBytes</a> (const uint8_t *bytes, int *index, int32_t min, uint32_t divisor)</td></tr>
<tr class="memdesc:abd01e92764da7f5a2169e952f5fbd85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint32_t from a byte stream by inverse integer scaling from 4 unsigned bytes in little endian order.  <br /></td></tr>
<tr class="separator:abd01e92764da7f5a2169e952f5fbd85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ba5deb606ce7e9abf6e500d7443359" id="r_a39ba5deb606ce7e9abf6e500d7443359"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39ba5deb606ce7e9abf6e500d7443359">uint32ScaledFrom4SignedBeBytes</a> (const uint8_t *bytes, int *index, uint32_t divisor)</td></tr>
<tr class="memdesc:a39ba5deb606ce7e9abf6e500d7443359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint32_t from a byte stream by inverse integer scaling from 4 signed bytes in big endian order.  <br /></td></tr>
<tr class="separator:a39ba5deb606ce7e9abf6e500d7443359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e7a55e9c4995fa94ce9b31dd710ca0" id="r_a04e7a55e9c4995fa94ce9b31dd710ca0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04e7a55e9c4995fa94ce9b31dd710ca0">uint32ScaledFrom4SignedLeBytes</a> (const uint8_t *bytes, int *index, uint32_t divisor)</td></tr>
<tr class="memdesc:a04e7a55e9c4995fa94ce9b31dd710ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint32_t from a byte stream by inverse integer scaling from 4 signed bytes in little endian order.  <br /></td></tr>
<tr class="separator:a04e7a55e9c4995fa94ce9b31dd710ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c586b3c7d1b5dffa3c49a4fe27b7eb" id="r_ad7c586b3c7d1b5dffa3c49a4fe27b7eb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7c586b3c7d1b5dffa3c49a4fe27b7eb">uint32ScaledFrom3UnsignedBeBytes</a> (const uint8_t *bytes, int *index, int32_t min, uint32_t divisor)</td></tr>
<tr class="memdesc:ad7c586b3c7d1b5dffa3c49a4fe27b7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint32_t from a byte stream by inverse integer scaling from 3 unsigned bytes in big endian order.  <br /></td></tr>
<tr class="separator:ad7c586b3c7d1b5dffa3c49a4fe27b7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad166bf409b7c902ea9dadb8eed839cfc" id="r_ad166bf409b7c902ea9dadb8eed839cfc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad166bf409b7c902ea9dadb8eed839cfc">uint32ScaledFrom3UnsignedLeBytes</a> (const uint8_t *bytes, int *index, int32_t min, uint32_t divisor)</td></tr>
<tr class="memdesc:ad166bf409b7c902ea9dadb8eed839cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint32_t from a byte stream by inverse integer scaling from 3 unsigned bytes in little endian order.  <br /></td></tr>
<tr class="separator:ad166bf409b7c902ea9dadb8eed839cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24e8bdebc1b003a6a49101e1ab5e5ad" id="r_ad24e8bdebc1b003a6a49101e1ab5e5ad"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad24e8bdebc1b003a6a49101e1ab5e5ad">uint32ScaledFrom3SignedBeBytes</a> (const uint8_t *bytes, int *index, uint32_t divisor)</td></tr>
<tr class="memdesc:ad24e8bdebc1b003a6a49101e1ab5e5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint32_t from a byte stream by inverse integer scaling from 3 signed bytes in big endian order.  <br /></td></tr>
<tr class="separator:ad24e8bdebc1b003a6a49101e1ab5e5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d24b4b107913eea939dee95f997fb82" id="r_a6d24b4b107913eea939dee95f997fb82"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d24b4b107913eea939dee95f997fb82">uint32ScaledFrom3SignedLeBytes</a> (const uint8_t *bytes, int *index, uint32_t divisor)</td></tr>
<tr class="memdesc:a6d24b4b107913eea939dee95f997fb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint32_t from a byte stream by inverse integer scaling from 3 signed bytes in little endian order.  <br /></td></tr>
<tr class="separator:a6d24b4b107913eea939dee95f997fb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e56232f27971931c4b64d16838072a" id="r_ad3e56232f27971931c4b64d16838072a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3e56232f27971931c4b64d16838072a">uint32ScaledFrom2UnsignedBeBytes</a> (const uint8_t *bytes, int *index, int32_t min, uint32_t divisor)</td></tr>
<tr class="memdesc:ad3e56232f27971931c4b64d16838072a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint32_t from a byte stream by inverse integer scaling from 2 unsigned bytes in big endian order.  <br /></td></tr>
<tr class="separator:ad3e56232f27971931c4b64d16838072a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b30994eb9e0c95d982d133a5d5959b4" id="r_a0b30994eb9e0c95d982d133a5d5959b4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b30994eb9e0c95d982d133a5d5959b4">uint32ScaledFrom2UnsignedLeBytes</a> (const uint8_t *bytes, int *index, int32_t min, uint32_t divisor)</td></tr>
<tr class="memdesc:a0b30994eb9e0c95d982d133a5d5959b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint32_t from a byte stream by inverse integer scaling from 2 unsigned bytes in little endian order.  <br /></td></tr>
<tr class="separator:a0b30994eb9e0c95d982d133a5d5959b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f42cf34be9ddec4b48e89723313ba99" id="r_a3f42cf34be9ddec4b48e89723313ba99"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f42cf34be9ddec4b48e89723313ba99">uint32ScaledFrom2SignedBeBytes</a> (const uint8_t *bytes, int *index, uint32_t divisor)</td></tr>
<tr class="memdesc:a3f42cf34be9ddec4b48e89723313ba99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint32_t from a byte stream by inverse integer scaling from 2 signed bytes in big endian order.  <br /></td></tr>
<tr class="separator:a3f42cf34be9ddec4b48e89723313ba99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a30a9116ab53e21d5f20f0fd7111cf5" id="r_a3a30a9116ab53e21d5f20f0fd7111cf5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a30a9116ab53e21d5f20f0fd7111cf5">uint32ScaledFrom2SignedLeBytes</a> (const uint8_t *bytes, int *index, uint32_t divisor)</td></tr>
<tr class="memdesc:a3a30a9116ab53e21d5f20f0fd7111cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint32_t from a byte stream by inverse integer scaling from 2 signed bytes in little endian order.  <br /></td></tr>
<tr class="separator:a3a30a9116ab53e21d5f20f0fd7111cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab340ce15764448a0ed0b27bf176b3b" id="r_aaab340ce15764448a0ed0b27bf176b3b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaab340ce15764448a0ed0b27bf176b3b">uint32ScaledFrom1UnsignedBytes</a> (const uint8_t *bytes, int *index, int32_t min, uint32_t divisor)</td></tr>
<tr class="memdesc:aaab340ce15764448a0ed0b27bf176b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint32_t from a byte stream by inverse integer scaling from 1 unsigned byte.  <br /></td></tr>
<tr class="separator:aaab340ce15764448a0ed0b27bf176b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f444bdfc74fb25028669ab06d0d58a" id="r_a42f444bdfc74fb25028669ab06d0d58a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42f444bdfc74fb25028669ab06d0d58a">uint32ScaledFrom1SignedBytes</a> (const uint8_t *bytes, int *index, uint32_t divisor)</td></tr>
<tr class="memdesc:a42f444bdfc74fb25028669ab06d0d58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint32_t from a byte stream by inverse integer scaling from 1 signed byte.  <br /></td></tr>
<tr class="separator:a42f444bdfc74fb25028669ab06d0d58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832596a1cf5af5ea755abee974abfc21" id="r_a832596a1cf5af5ea755abee974abfc21"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a832596a1cf5af5ea755abee974abfc21">int32ScaledFromBitfield</a> (unsigned int <a class="el" href="AP__JSON_8cpp.html#a37700c57263ada4716d7dbbc43089a24">value</a>, int32_t min, uint32_t divisor)</td></tr>
<tr class="memdesc:a832596a1cf5af5ea755abee974abfc21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a int32_t using inverse integer scaling from the base integer type used for bitfields.  <br /></td></tr>
<tr class="separator:a832596a1cf5af5ea755abee974abfc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bd8d4c89651965da505903fe7fd07a" id="r_a46bd8d4c89651965da505903fe7fd07a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46bd8d4c89651965da505903fe7fd07a">int32ScaledFrom4UnsignedBeBytes</a> (const uint8_t *bytes, int *index, int32_t min, uint32_t divisor)</td></tr>
<tr class="memdesc:a46bd8d4c89651965da505903fe7fd07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int32_t from a byte stream by inverse integer scaling from 4 unsigned bytes in big endian order.  <br /></td></tr>
<tr class="separator:a46bd8d4c89651965da505903fe7fd07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666183c51cc19173c37aafa06fb102d1" id="r_a666183c51cc19173c37aafa06fb102d1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a666183c51cc19173c37aafa06fb102d1">int32ScaledFrom4UnsignedLeBytes</a> (const uint8_t *bytes, int *index, int32_t min, uint32_t divisor)</td></tr>
<tr class="memdesc:a666183c51cc19173c37aafa06fb102d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int32_t from a byte stream by inverse integer scaling from 4 unsigned bytes in little endian order.  <br /></td></tr>
<tr class="separator:a666183c51cc19173c37aafa06fb102d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14b0957b07b56dc89be3cb26b5acec1" id="r_ab14b0957b07b56dc89be3cb26b5acec1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab14b0957b07b56dc89be3cb26b5acec1">int32ScaledFrom4SignedBeBytes</a> (const uint8_t *bytes, int *index, uint32_t divisor)</td></tr>
<tr class="memdesc:ab14b0957b07b56dc89be3cb26b5acec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int32_t from a byte stream by inverse integer scaling from 4 signed bytes in big endian order.  <br /></td></tr>
<tr class="separator:ab14b0957b07b56dc89be3cb26b5acec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f429ff91bba10e0473a7354232b90e" id="r_a73f429ff91bba10e0473a7354232b90e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73f429ff91bba10e0473a7354232b90e">int32ScaledFrom4SignedLeBytes</a> (const uint8_t *bytes, int *index, uint32_t divisor)</td></tr>
<tr class="memdesc:a73f429ff91bba10e0473a7354232b90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int32_t from a byte stream by inverse integer scaling from 4 signed bytes in little endian order.  <br /></td></tr>
<tr class="separator:a73f429ff91bba10e0473a7354232b90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ff306b5f8cad8393198ca3ee9c5bd1" id="r_a12ff306b5f8cad8393198ca3ee9c5bd1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12ff306b5f8cad8393198ca3ee9c5bd1">int32ScaledFrom3UnsignedBeBytes</a> (const uint8_t *bytes, int *index, int32_t min, uint32_t divisor)</td></tr>
<tr class="memdesc:a12ff306b5f8cad8393198ca3ee9c5bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int32_t from a byte stream by inverse integer scaling from 3 unsigned bytes in big endian order.  <br /></td></tr>
<tr class="separator:a12ff306b5f8cad8393198ca3ee9c5bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc0fbffa62f8fc291827603bbd075b5" id="r_a2bc0fbffa62f8fc291827603bbd075b5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bc0fbffa62f8fc291827603bbd075b5">int32ScaledFrom3UnsignedLeBytes</a> (const uint8_t *bytes, int *index, int32_t min, uint32_t divisor)</td></tr>
<tr class="memdesc:a2bc0fbffa62f8fc291827603bbd075b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int32_t from a byte stream by inverse integer scaling from 3 unsigned bytes in little endian order.  <br /></td></tr>
<tr class="separator:a2bc0fbffa62f8fc291827603bbd075b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e99d9e19acab60f9e6fd52c63fb50b" id="r_aa4e99d9e19acab60f9e6fd52c63fb50b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4e99d9e19acab60f9e6fd52c63fb50b">int32ScaledFrom3SignedBeBytes</a> (const uint8_t *bytes, int *index, uint32_t divisor)</td></tr>
<tr class="memdesc:aa4e99d9e19acab60f9e6fd52c63fb50b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int32_t from a byte stream by inverse integer scaling from 3 signed bytes in big endian order.  <br /></td></tr>
<tr class="separator:aa4e99d9e19acab60f9e6fd52c63fb50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30b1c178d40c6381babb1179f8a5471" id="r_ab30b1c178d40c6381babb1179f8a5471"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab30b1c178d40c6381babb1179f8a5471">int32ScaledFrom3SignedLeBytes</a> (const uint8_t *bytes, int *index, uint32_t divisor)</td></tr>
<tr class="memdesc:ab30b1c178d40c6381babb1179f8a5471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int32_t from a byte stream by inverse integer scaling from 3 signed bytes in little endian order.  <br /></td></tr>
<tr class="separator:ab30b1c178d40c6381babb1179f8a5471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa45a5dad8692ea98f1c7621747fe7ff" id="r_aaa45a5dad8692ea98f1c7621747fe7ff"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa45a5dad8692ea98f1c7621747fe7ff">int32ScaledFrom2UnsignedBeBytes</a> (const uint8_t *bytes, int *index, int32_t min, uint32_t divisor)</td></tr>
<tr class="memdesc:aaa45a5dad8692ea98f1c7621747fe7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int32_t from a byte stream by inverse integer scaling from 2 unsigned bytes in big endian order.  <br /></td></tr>
<tr class="separator:aaa45a5dad8692ea98f1c7621747fe7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377fd78076c5e663dca8d1ecb87a002d" id="r_a377fd78076c5e663dca8d1ecb87a002d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a377fd78076c5e663dca8d1ecb87a002d">int32ScaledFrom2UnsignedLeBytes</a> (const uint8_t *bytes, int *index, int32_t min, uint32_t divisor)</td></tr>
<tr class="memdesc:a377fd78076c5e663dca8d1ecb87a002d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int32_t from a byte stream by inverse integer scaling from 2 unsigned bytes in little endian order.  <br /></td></tr>
<tr class="separator:a377fd78076c5e663dca8d1ecb87a002d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae439d612f4047e0841e02640487360cf" id="r_ae439d612f4047e0841e02640487360cf"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae439d612f4047e0841e02640487360cf">int32ScaledFrom2SignedBeBytes</a> (const uint8_t *bytes, int *index, uint32_t divisor)</td></tr>
<tr class="memdesc:ae439d612f4047e0841e02640487360cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int32_t from a byte stream by inverse integer scaling from 2 signed bytes in big endian order.  <br /></td></tr>
<tr class="separator:ae439d612f4047e0841e02640487360cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169750a547c21d331230386843a674f0" id="r_a169750a547c21d331230386843a674f0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a169750a547c21d331230386843a674f0">int32ScaledFrom2SignedLeBytes</a> (const uint8_t *bytes, int *index, uint32_t divisor)</td></tr>
<tr class="memdesc:a169750a547c21d331230386843a674f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int32_t from a byte stream by inverse integer scaling from 2 signed bytes in little endian order.  <br /></td></tr>
<tr class="separator:a169750a547c21d331230386843a674f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7af078f9f85a629d6e07e5c8a785156" id="r_af7af078f9f85a629d6e07e5c8a785156"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7af078f9f85a629d6e07e5c8a785156">int32ScaledFrom1UnsignedBytes</a> (const uint8_t *bytes, int *index, int32_t min, uint32_t divisor)</td></tr>
<tr class="memdesc:af7af078f9f85a629d6e07e5c8a785156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int32_t from a byte stream by inverse integer scaling from 1 unsigned byte.  <br /></td></tr>
<tr class="separator:af7af078f9f85a629d6e07e5c8a785156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e609acc0ff055ccc379ca1dbf807e1" id="r_a65e609acc0ff055ccc379ca1dbf807e1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65e609acc0ff055ccc379ca1dbf807e1">int32ScaledFrom1SignedBytes</a> (const uint8_t *bytes, int *index, uint32_t divisor)</td></tr>
<tr class="memdesc:a65e609acc0ff055ccc379ca1dbf807e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int32_t from a byte stream by inverse integer scaling from 1 signed byte.  <br /></td></tr>
<tr class="separator:a65e609acc0ff055ccc379ca1dbf807e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ea69be25bcf56a4c40ae99fadfe229" id="r_aa0ea69be25bcf56a4c40ae99fadfe229"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0ea69be25bcf56a4c40ae99fadfe229">uint16ScaledFromBitfield</a> (unsigned int <a class="el" href="AP__JSON_8cpp.html#a37700c57263ada4716d7dbbc43089a24">value</a>, int16_t min, uint16_t divisor)</td></tr>
<tr class="memdesc:aa0ea69be25bcf56a4c40ae99fadfe229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a uint16_t using inverse integer scaling from the base integer type used for bitfields.  <br /></td></tr>
<tr class="separator:aa0ea69be25bcf56a4c40ae99fadfe229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a22e78b8bb9db400da4c263d9014d08" id="r_a6a22e78b8bb9db400da4c263d9014d08"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a22e78b8bb9db400da4c263d9014d08">uint16ScaledFrom2UnsignedBeBytes</a> (const uint8_t *bytes, int *index, int16_t min, uint16_t divisor)</td></tr>
<tr class="memdesc:a6a22e78b8bb9db400da4c263d9014d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint16_t from a byte stream by inverse integer scaling from 2 unsigned bytes in big endian order.  <br /></td></tr>
<tr class="separator:a6a22e78b8bb9db400da4c263d9014d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0428820f368fff54503e56bbb87f5d8" id="r_ae0428820f368fff54503e56bbb87f5d8"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0428820f368fff54503e56bbb87f5d8">uint16ScaledFrom2UnsignedLeBytes</a> (const uint8_t *bytes, int *index, int16_t min, uint16_t divisor)</td></tr>
<tr class="memdesc:ae0428820f368fff54503e56bbb87f5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint16_t from a byte stream by inverse integer scaling from 2 unsigned bytes in little endian order.  <br /></td></tr>
<tr class="separator:ae0428820f368fff54503e56bbb87f5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33bea4a8d5566a8f02fd7e6fb778ac9" id="r_ad33bea4a8d5566a8f02fd7e6fb778ac9"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad33bea4a8d5566a8f02fd7e6fb778ac9">uint16ScaledFrom2SignedBeBytes</a> (const uint8_t *bytes, int *index, uint16_t divisor)</td></tr>
<tr class="memdesc:ad33bea4a8d5566a8f02fd7e6fb778ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint16_t from a byte stream by inverse integer scaling from 2 signed bytes in big endian order.  <br /></td></tr>
<tr class="separator:ad33bea4a8d5566a8f02fd7e6fb778ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eea151e0c620113f51724fdd02c925f" id="r_a2eea151e0c620113f51724fdd02c925f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2eea151e0c620113f51724fdd02c925f">uint16ScaledFrom2SignedLeBytes</a> (const uint8_t *bytes, int *index, uint16_t divisor)</td></tr>
<tr class="memdesc:a2eea151e0c620113f51724fdd02c925f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint16_t from a byte stream by inverse integer scaling from 2 signed bytes in little endian order.  <br /></td></tr>
<tr class="separator:a2eea151e0c620113f51724fdd02c925f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490dddb84344fca31dcda6a306d64d48" id="r_a490dddb84344fca31dcda6a306d64d48"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a490dddb84344fca31dcda6a306d64d48">uint16ScaledFrom1UnsignedBytes</a> (const uint8_t *bytes, int *index, int16_t min, uint16_t divisor)</td></tr>
<tr class="memdesc:a490dddb84344fca31dcda6a306d64d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint16_t from a byte stream by inverse integer scaling from 1 unsigned byte.  <br /></td></tr>
<tr class="separator:a490dddb84344fca31dcda6a306d64d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8b49ff6465832c98e1558b60d93a79" id="r_a2c8b49ff6465832c98e1558b60d93a79"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c8b49ff6465832c98e1558b60d93a79">uint16ScaledFrom1SignedBytes</a> (const uint8_t *bytes, int *index, uint16_t divisor)</td></tr>
<tr class="memdesc:a2c8b49ff6465832c98e1558b60d93a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint16_t from a byte stream by inverse integer scaling from 1 signed byte.  <br /></td></tr>
<tr class="separator:a2c8b49ff6465832c98e1558b60d93a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40381e644eaee31ba8d6081b0e26806" id="r_aa40381e644eaee31ba8d6081b0e26806"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa40381e644eaee31ba8d6081b0e26806">int16ScaledFromBitfield</a> (unsigned int <a class="el" href="AP__JSON_8cpp.html#a37700c57263ada4716d7dbbc43089a24">value</a>, int16_t min, uint16_t divisor)</td></tr>
<tr class="memdesc:aa40381e644eaee31ba8d6081b0e26806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a int16_t using inverse integer scaling from the base integer type used for bitfields.  <br /></td></tr>
<tr class="separator:aa40381e644eaee31ba8d6081b0e26806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd9313d77e392a22af0f98de90f296d" id="r_acbd9313d77e392a22af0f98de90f296d"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbd9313d77e392a22af0f98de90f296d">int16ScaledFrom2UnsignedBeBytes</a> (const uint8_t *bytes, int *index, int16_t min, uint16_t divisor)</td></tr>
<tr class="memdesc:acbd9313d77e392a22af0f98de90f296d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int16_t from a byte stream by inverse integer scaling from 2 unsigned bytes in big endian order.  <br /></td></tr>
<tr class="separator:acbd9313d77e392a22af0f98de90f296d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267e1faa2ec8371348aecddf5f384102" id="r_a267e1faa2ec8371348aecddf5f384102"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a267e1faa2ec8371348aecddf5f384102">int16ScaledFrom2UnsignedLeBytes</a> (const uint8_t *bytes, int *index, int16_t min, uint16_t divisor)</td></tr>
<tr class="memdesc:a267e1faa2ec8371348aecddf5f384102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int16_t from a byte stream by inverse integer scaling from 2 unsigned bytes in little endian order.  <br /></td></tr>
<tr class="separator:a267e1faa2ec8371348aecddf5f384102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6745e27b2ad237006f23e2482395552b" id="r_a6745e27b2ad237006f23e2482395552b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6745e27b2ad237006f23e2482395552b">int16ScaledFrom2SignedBeBytes</a> (const uint8_t *bytes, int *index, uint16_t divisor)</td></tr>
<tr class="memdesc:a6745e27b2ad237006f23e2482395552b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int16_t from a byte stream by inverse integer scaling from 2 signed bytes in big endian order.  <br /></td></tr>
<tr class="separator:a6745e27b2ad237006f23e2482395552b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576082ac573ea5e86277e504ce2ddc2a" id="r_a576082ac573ea5e86277e504ce2ddc2a"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a576082ac573ea5e86277e504ce2ddc2a">int16ScaledFrom2SignedLeBytes</a> (const uint8_t *bytes, int *index, uint16_t divisor)</td></tr>
<tr class="memdesc:a576082ac573ea5e86277e504ce2ddc2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int16_t from a byte stream by inverse integer scaling from 2 signed bytes in little endian order.  <br /></td></tr>
<tr class="separator:a576082ac573ea5e86277e504ce2ddc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14fad18a3937dcfe83a91c1e2bd4e1c" id="r_af14fad18a3937dcfe83a91c1e2bd4e1c"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af14fad18a3937dcfe83a91c1e2bd4e1c">int16ScaledFrom1UnsignedBytes</a> (const uint8_t *bytes, int *index, int16_t min, uint16_t divisor)</td></tr>
<tr class="memdesc:af14fad18a3937dcfe83a91c1e2bd4e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int16_t from a byte stream by inverse integer scaling from 1 unsigned byte.  <br /></td></tr>
<tr class="separator:af14fad18a3937dcfe83a91c1e2bd4e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa707608ef756f47c5418ec299a0106c" id="r_afa707608ef756f47c5418ec299a0106c"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa707608ef756f47c5418ec299a0106c">int16ScaledFrom1SignedBytes</a> (const uint8_t *bytes, int *index, uint16_t divisor)</td></tr>
<tr class="memdesc:afa707608ef756f47c5418ec299a0106c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int16_t from a byte stream by inverse integer scaling from 1 signed byte.  <br /></td></tr>
<tr class="separator:afa707608ef756f47c5418ec299a0106c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f73c9d6f30767dc199c6dcdf3419d5a" id="r_a4f73c9d6f30767dc199c6dcdf3419d5a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f73c9d6f30767dc199c6dcdf3419d5a">uint8ScaledFromBitfield</a> (unsigned int <a class="el" href="AP__JSON_8cpp.html#a37700c57263ada4716d7dbbc43089a24">value</a>, int8_t min, uint8_t divisor)</td></tr>
<tr class="memdesc:a4f73c9d6f30767dc199c6dcdf3419d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a uint8_t using inverse integer scaling from the base integer type used for bitfields.  <br /></td></tr>
<tr class="separator:a4f73c9d6f30767dc199c6dcdf3419d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67acf1fbc9c0dc4efa929e2ecf1c3639" id="r_a67acf1fbc9c0dc4efa929e2ecf1c3639"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67acf1fbc9c0dc4efa929e2ecf1c3639">uint8ScaledFrom1UnsignedBytes</a> (const uint8_t *bytes, int *index, int8_t min, uint8_t divisor)</td></tr>
<tr class="memdesc:a67acf1fbc9c0dc4efa929e2ecf1c3639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint8_t from a byte stream by inverse integer scaling from 1 unsigned byte.  <br /></td></tr>
<tr class="separator:a67acf1fbc9c0dc4efa929e2ecf1c3639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9600e1f5666c1afcc50a9485638331ef" id="r_a9600e1f5666c1afcc50a9485638331ef"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9600e1f5666c1afcc50a9485638331ef">uint8ScaledFrom1SignedBytes</a> (const uint8_t *bytes, int *index, uint8_t divisor)</td></tr>
<tr class="memdesc:a9600e1f5666c1afcc50a9485638331ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a uint8_t from a byte stream by inverse integer scaling from 1 signed byte.  <br /></td></tr>
<tr class="separator:a9600e1f5666c1afcc50a9485638331ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4b950f840234f67713ada19d4dab8f" id="r_a8a4b950f840234f67713ada19d4dab8f"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a4b950f840234f67713ada19d4dab8f">int8ScaledFromBitfield</a> (unsigned int <a class="el" href="AP__JSON_8cpp.html#a37700c57263ada4716d7dbbc43089a24">value</a>, int8_t min, uint8_t divisor)</td></tr>
<tr class="memdesc:a8a4b950f840234f67713ada19d4dab8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a int8_t using inverse integer scaling from the base integer type used for bitfields.  <br /></td></tr>
<tr class="separator:a8a4b950f840234f67713ada19d4dab8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c70326a64bae37b2ed78b9f4778882e" id="r_a3c70326a64bae37b2ed78b9f4778882e"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c70326a64bae37b2ed78b9f4778882e">int8ScaledFrom1UnsignedBytes</a> (const uint8_t *bytes, int *index, int8_t min, uint8_t divisor)</td></tr>
<tr class="memdesc:a3c70326a64bae37b2ed78b9f4778882e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int8_t from a byte stream by inverse integer scaling from 1 unsigned byte.  <br /></td></tr>
<tr class="separator:a3c70326a64bae37b2ed78b9f4778882e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3880f2c4f6387b5aad0c42120d6e3457" id="r_a3880f2c4f6387b5aad0c42120d6e3457"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3880f2c4f6387b5aad0c42120d6e3457">int8ScaledFrom1SignedBytes</a> (const uint8_t *bytes, int *index, uint8_t divisor)</td></tr>
<tr class="memdesc:a3880f2c4f6387b5aad0c42120d6e3457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a int8_t from a byte stream by inverse integer scaling from 1 signed byte.  <br /></td></tr>
<tr class="separator:a3880f2c4f6387b5aad0c42120d6e3457"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="af2f32237ad49a8c1f657bfc2f4067d32" name="af2f32237ad49a8c1f657bfc2f4067d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f32237ad49a8c1f657bfc2f4067d32">&#9670;&#160;</a></span>float32ScaledFrom1SignedBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float float32ScaledFrom1SignedBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>invscaler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a float from a byte stream by inverse floating point scaling from 1 signed byte. </p>
<p>Decode a float from a byte stream by inverse floating point scaling from 1 signed byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 1 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">invscaler</td><td>is multiplied by the decoded integer to create the return value. invscaler should be the inverse of the scaler given to the encode function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded*invscaler. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00264">264</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="ECUPackets_8c_source.html#l02119">decodeECU_RPMLoopCalibrationPacketStructure()</a>, and <a class="el" href="ECUPackets_8c_source.html#l00574">decodeECU_TelemetrySlow1PacketStructure()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_af2f32237ad49a8c1f657bfc2f4067d32_icgraph.svg" width="488" height="115"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ae7fb6f8e62c85655cba5722519e3b530" name="ae7fb6f8e62c85655cba5722519e3b530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7fb6f8e62c85655cba5722519e3b530">&#9670;&#160;</a></span>float32ScaledFrom1UnsignedBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float float32ScaledFrom1UnsignedBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>invscaler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a float from a byte stream by inverse floating point scaling from 1 unsigned byte. </p>
<p>Decode a float from a byte stream by inverse floating point scaling from 1 unsigned byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 1 when this function is complete. </td></tr>
    <tr><td class="paramname">invscaler</td><td>is multiplied by the decoded integer to create the return value. invscaler should be the inverse of the scaler given to the encode function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded*invscaler. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00247">247</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="ECUSettings_8c_source.html#l00381">decodeECU_GovernorSettingsPacketStructure()</a>, <a class="el" href="ECUPackets_8c_source.html#l02119">decodeECU_RPMLoopCalibrationPacketStructure()</a>, <a class="el" href="ECUPackets_8c_source.html#l03359">decodeECU_SetThrottleCurveElementPacket()</a>, <a class="el" href="ECUPackets_8c_source.html#l00364">decodeECU_TelemetryFastPacket()</a>, <a class="el" href="ECUPackets_8c_source.html#l00278">decodeECU_TelemetryFastPacketStructure()</a>, <a class="el" href="ECUPackets_8c_source.html#l00468">decodeECU_TelemetrySlow0PacketStructure()</a>, <a class="el" href="ECUPackets_8c_source.html#l00574">decodeECU_TelemetrySlow1PacketStructure()</a>, <a class="el" href="ECUPackets_8c_source.html#l00665">decodeECU_TelemetrySlow2PacketStructure()</a>, <a class="el" href="ECUPackets_8c_source.html#l02812">decodeECU_ThrottleCurve1Packet()</a>, <a class="el" href="ECUPackets_8c_source.html#l02752">decodeECU_ThrottleCurvePacket()</a>, <a class="el" href="ESCPackets_8c_source.html#l02768">decodeESC_ProtectionValuesPacket()</a>, <a class="el" href="ESCPackets_8c_source.html#l02617">decodeESC_ProtectionValuesPacketStructure()</a>, <a class="el" href="ESCPackets_8c_source.html#l01800">decodeESC_StatusCPacket()</a>, and <a class="el" href="ESCPackets_8c_source.html#l01713">decodeESC_StatusCPacketStructure()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_ae7fb6f8e62c85655cba5722519e3b530_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="ad7856923a13cbba11d5ca6c496c6eb2c" name="ad7856923a13cbba11d5ca6c496c6eb2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7856923a13cbba11d5ca6c496c6eb2c">&#9670;&#160;</a></span>float32ScaledFrom2SignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float float32ScaledFrom2SignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>invscaler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a float from a byte stream by inverse floating point scaling from 2 signed bytes in big endian order. </p>
<p>Decode a float from a byte stream by inverse floating point scaling from 2 signed bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 2 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">invscaler</td><td>is multiplied by the decoded integer to create the return value. invscaler should be the inverse of the scaler given to the encode function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded*invscaler. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00214">214</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="ECUPackets_8c_source.html#l01102">decodeECU_PumpDebugPacketStructure()</a>, <a class="el" href="ESCPackets_8c_source.html#l02205">decodeESC_ControlLoopOutputsPacket()</a>, <a class="el" href="ESCPackets_8c_source.html#l02126">decodeESC_ControlLoopOutputsPacketStructure()</a>, <a class="el" href="ESCPackets_8c_source.html#l04720">decodeESC_TelltaleValuesPacket()</a>, and <a class="el" href="ESCPackets_8c_source.html#l04531">decodeESC_TelltaleValuesPacketStructure()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_ad7856923a13cbba11d5ca6c496c6eb2c_cgraph.svg" width="396" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_ad7856923a13cbba11d5ca6c496c6eb2c_icgraph.svg" width="484" height="307"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a4572085e1aee5acd3d9d7d4a77e01d4e" name="a4572085e1aee5acd3d9d7d4a77e01d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4572085e1aee5acd3d9d7d4a77e01d4e">&#9670;&#160;</a></span>float32ScaledFrom2SignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float float32ScaledFrom2SignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>invscaler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a float from a byte stream by inverse floating point scaling from 2 signed bytes in little endian order. </p>
<p>Decode a float from a byte stream by inverse floating point scaling from 2 signed bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 2 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">invscaler</td><td>is multiplied by the decoded integer to create the return value. invscaler should be the inverse of the scaler given to the encode function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded*invscaler. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00231">231</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a4572085e1aee5acd3d9d7d4a77e01d4e_cgraph.svg" width="394" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a8cfa1ff201520a07e1e62b437bd7d5a2" name="a8cfa1ff201520a07e1e62b437bd7d5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfa1ff201520a07e1e62b437bd7d5a2">&#9670;&#160;</a></span>float32ScaledFrom2UnsignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float float32ScaledFrom2UnsignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>invscaler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a float from a byte stream by inverse floating point scaling from 2 unsigned bytes in big endian order. </p>
<p>Decode a float from a byte stream by inverse floating point scaling from 2 unsigned bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 2 when this function is complete. </td></tr>
    <tr><td class="paramname">invscaler</td><td>is multiplied by the decoded integer to create the return value. invscaler should be the inverse of the scaler given to the encode function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded*invscaler. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00181">181</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="ECUPackets_8c_source.html#l01522">decodeECU_CHTLoopSettingsPacket()</a>, <a class="el" href="ECUPackets_8c_source.html#l01415">decodeECU_CHTLoopSettingsPacketStructure()</a>, <a class="el" href="ECUPackets_8c_source.html#l02610">decodeECU_Pump2ConfigPacketStructure()</a>, <a class="el" href="ECUPackets_8c_source.html#l02522">decodeECU_PumpConfigPacketStructure()</a>, <a class="el" href="ECUPackets_8c_source.html#l01102">decodeECU_PumpDebugPacketStructure()</a>, <a class="el" href="ECUPackets_8c_source.html#l02119">decodeECU_RPMLoopCalibrationPacketStructure()</a>, <a class="el" href="ECUPackets_8c_source.html#l00468">decodeECU_TelemetrySlow0PacketStructure()</a>, <a class="el" href="ECUPackets_8c_source.html#l00574">decodeECU_TelemetrySlow1PacketStructure()</a>, <a class="el" href="ECUPackets_8c_source.html#l00665">decodeECU_TelemetrySlow2PacketStructure()</a>, <a class="el" href="ECUPackets_8c_source.html#l00047">decodeECU_ThrottleCommandPacket()</a>, <a class="el" href="ESCDefines_8c_source.html#l00780">decodeESC_ControlLoopCommon_t()</a>, <a class="el" href="ESCPackets_8c_source.html#l00192">decodeESC_RPMControlLoopSettings_t()</a>, and <a class="el" href="ESCPackets_8c_source.html#l00112">decodeESC_RPMControlLoopSettingsPacketStructure()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a8cfa1ff201520a07e1e62b437bd7d5a2_cgraph.svg" width="422" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a8cfa1ff201520a07e1e62b437bd7d5a2_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="aaca8dee3b750d6cf5c1687acc3ccf1c6" name="aaca8dee3b750d6cf5c1687acc3ccf1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca8dee3b750d6cf5c1687acc3ccf1c6">&#9670;&#160;</a></span>float32ScaledFrom2UnsignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float float32ScaledFrom2UnsignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>invscaler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a float from a byte stream by inverse floating point scaling from 2 unsigned bytes in little endian order. </p>
<p>Decode a float from a byte stream by inverse floating point scaling from 2 unsigned bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 2 when this function is complete. </td></tr>
    <tr><td class="paramname">invscaler</td><td>is multiplied by the decoded integer to create the return value. invscaler should be the inverse of the scaler given to the encode function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded*invscaler. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00197">197</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_aaca8dee3b750d6cf5c1687acc3ccf1c6_cgraph.svg" width="419" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a72a6d774fa88d2ec1f587637d322419b" name="a72a6d774fa88d2ec1f587637d322419b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a6d774fa88d2ec1f587637d322419b">&#9670;&#160;</a></span>float32ScaledFrom3SignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float float32ScaledFrom3SignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>invscaler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a float from a byte stream by inverse floating point scaling from 3 signed bytes in big endian order. </p>
<p>Decode a float from a byte stream by inverse floating point scaling from 3 signed bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 3 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">invscaler</td><td>is multiplied by the decoded integer to create the return value. invscaler should be the inverse of the scaler given to the encode function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded*invscaler. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00148">148</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a72a6d774fa88d2ec1f587637d322419b_cgraph.svg" width="396" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a80f26f6ee50b2a38bbcae24e109f9508" name="a80f26f6ee50b2a38bbcae24e109f9508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f26f6ee50b2a38bbcae24e109f9508">&#9670;&#160;</a></span>float32ScaledFrom3SignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float float32ScaledFrom3SignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>invscaler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a float from a byte stream by inverse floating point scaling from 3 signed bytes in little endian order. </p>
<p>Decode a float from a byte stream by inverse floating point scaling from 3 signed bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 3 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">invscaler</td><td>is multiplied by the decoded integer to create the return value. invscaler should be the inverse of the scaler given to the encode function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded*invscaler. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00165">165</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a80f26f6ee50b2a38bbcae24e109f9508_cgraph.svg" width="394" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a6236aa5906391280a0dd2a71c41314a1" name="a6236aa5906391280a0dd2a71c41314a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6236aa5906391280a0dd2a71c41314a1">&#9670;&#160;</a></span>float32ScaledFrom3UnsignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float float32ScaledFrom3UnsignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>invscaler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a float from a byte stream by inverse floating point scaling from 3 unsigned bytes in big endian order. </p>
<p>Decode a float from a byte stream by inverse floating point scaling from 3 unsigned bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 3 when this function is complete. </td></tr>
    <tr><td class="paramname">invscaler</td><td>is multiplied by the decoded integer to create the return value. invscaler should be the inverse of the scaler given to the encode function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded*invscaler. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00115">115</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a6236aa5906391280a0dd2a71c41314a1_cgraph.svg" width="422" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a1346abe203aeb41c42d843c551210afe" name="a1346abe203aeb41c42d843c551210afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1346abe203aeb41c42d843c551210afe">&#9670;&#160;</a></span>float32ScaledFrom3UnsignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float float32ScaledFrom3UnsignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>invscaler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a float from a byte stream by inverse floating point scaling from 3 unsigned bytes in little endian order. </p>
<p>Decode a float from a byte stream by inverse floating point scaling from 3 unsigned bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 3 when this function is complete. </td></tr>
    <tr><td class="paramname">invscaler</td><td>is multiplied by the decoded integer to create the return value. invscaler should be the inverse of the scaler given to the encode function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded*invscaler. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00131">131</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a1346abe203aeb41c42d843c551210afe_cgraph.svg" width="419" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a1da83420a58598168e022bfe97fed71c" name="a1da83420a58598168e022bfe97fed71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da83420a58598168e022bfe97fed71c">&#9670;&#160;</a></span>float32ScaledFrom4SignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float float32ScaledFrom4SignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>invscaler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a float from a byte stream by inverse floating point scaling from 4 signed bytes in big endian order. </p>
<p>Decode a float from a byte stream by inverse floating point scaling from 4 signed bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 4 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">invscaler</td><td>is multiplied by the decoded integer to create the return value. invscaler should be the inverse of the scaler given to the encode function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded*invscaler. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00082">82</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a1da83420a58598168e022bfe97fed71c_cgraph.svg" width="396" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ae922f64ce0cff6ba036eff42f936814a" name="ae922f64ce0cff6ba036eff42f936814a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae922f64ce0cff6ba036eff42f936814a">&#9670;&#160;</a></span>float32ScaledFrom4SignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float float32ScaledFrom4SignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>invscaler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a float from a byte stream by inverse floating point scaling from 4 signed bytes in little endian order. </p>
<p>Decode a float from a byte stream by inverse floating point scaling from 4 signed bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 4 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">invscaler</td><td>is multiplied by the decoded integer to create the return value. invscaler should be the inverse of the scaler given to the encode function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded*invscaler. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00099">99</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_ae922f64ce0cff6ba036eff42f936814a_cgraph.svg" width="394" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a4d1449e8c64eaf763ebe0922321c33b1" name="a4d1449e8c64eaf763ebe0922321c33b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1449e8c64eaf763ebe0922321c33b1">&#9670;&#160;</a></span>float32ScaledFrom4UnsignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float float32ScaledFrom4UnsignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>invscaler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a float from a byte stream by inverse floating point scaling from 4 unsigned bytes in big endian order. </p>
<p>Decode a float from a byte stream by inverse floating point scaling from 4 unsigned bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 4 when this function is complete. </td></tr>
    <tr><td class="paramname">invscaler</td><td>is multiplied by the decoded integer to create the return value. invscaler should be the inverse of the scaler given to the encode function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded*invscaler. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00049">49</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a4d1449e8c64eaf763ebe0922321c33b1_cgraph.svg" width="422" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a77105738ce49df0481e5a48ec9f19bc3" name="a77105738ce49df0481e5a48ec9f19bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77105738ce49df0481e5a48ec9f19bc3">&#9670;&#160;</a></span>float32ScaledFrom4UnsignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float float32ScaledFrom4UnsignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>invscaler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a float from a byte stream by inverse floating point scaling from 4 unsigned bytes in little endian order. </p>
<p>Decode a float from a byte stream by inverse floating point scaling from 4 unsigned bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 4 when this function is complete. </td></tr>
    <tr><td class="paramname">invscaler</td><td>is multiplied by the decoded integer to create the return value. invscaler should be the inverse of the scaler given to the encode function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded*invscaler. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00065">65</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a77105738ce49df0481e5a48ec9f19bc3_cgraph.svg" width="419" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a4c8382ef91a6ab1e4df1eadf26bc756d" name="a4c8382ef91a6ab1e4df1eadf26bc756d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8382ef91a6ab1e4df1eadf26bc756d">&#9670;&#160;</a></span>float32ScaledFromBitfield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float float32ScaledFromBitfield </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>value</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>invscaler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a float using inverse floating point scaling from the base integer type used for bitfields. </p>
<p>Compute a float using inverse floating point scaling from the base integer type used for bitfields. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is the integer bitfield number to inverse scale </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be represented. </td></tr>
    <tr><td class="paramname">invscaler</td><td>is multiplied by the integer to create the return value. invscaler should be the inverse of the scaler given to the scaling function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + value*invscaler. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00033">33</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

</div>
</div>
<a id="afa707608ef756f47c5418ec299a0106c" name="afa707608ef756f47c5418ec299a0106c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa707608ef756f47c5418ec299a0106c">&#9670;&#160;</a></span>int16ScaledFrom1SignedBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t int16ScaledFrom1SignedBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int16_t from a byte stream by inverse integer scaling from 1 signed byte. </p>
<p>Decode a int16_t from a byte stream by inverse integer scaling from 1 signed byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 1 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00940">940</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

</div>
</div>
<a id="af14fad18a3937dcfe83a91c1e2bd4e1c" name="af14fad18a3937dcfe83a91c1e2bd4e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14fad18a3937dcfe83a91c1e2bd4e1c">&#9670;&#160;</a></span>int16ScaledFrom1UnsignedBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t int16ScaledFrom1UnsignedBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int16_t from a byte stream by inverse integer scaling from 1 unsigned byte. </p>
<p>Decode a int16_t from a byte stream by inverse integer scaling from 1 unsigned byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 1 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00925">925</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

</div>
</div>
<a id="a6745e27b2ad237006f23e2482395552b" name="a6745e27b2ad237006f23e2482395552b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6745e27b2ad237006f23e2482395552b">&#9670;&#160;</a></span>int16ScaledFrom2SignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t int16ScaledFrom2SignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int16_t from a byte stream by inverse integer scaling from 2 signed bytes in big endian order. </p>
<p>Decode a int16_t from a byte stream by inverse integer scaling from 2 signed bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 2 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00894">894</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a6745e27b2ad237006f23e2482395552b_cgraph.svg" width="402" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a576082ac573ea5e86277e504ce2ddc2a" name="a576082ac573ea5e86277e504ce2ddc2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576082ac573ea5e86277e504ce2ddc2a">&#9670;&#160;</a></span>int16ScaledFrom2SignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t int16ScaledFrom2SignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int16_t from a byte stream by inverse integer scaling from 2 signed bytes in little endian order. </p>
<p>Decode a int16_t from a byte stream by inverse integer scaling from 2 signed bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 2 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00909">909</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a576082ac573ea5e86277e504ce2ddc2a_cgraph.svg" width="398" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="acbd9313d77e392a22af0f98de90f296d" name="acbd9313d77e392a22af0f98de90f296d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd9313d77e392a22af0f98de90f296d">&#9670;&#160;</a></span>int16ScaledFrom2UnsignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t int16ScaledFrom2UnsignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int16_t from a byte stream by inverse integer scaling from 2 unsigned bytes in big endian order. </p>
<p>Decode a int16_t from a byte stream by inverse integer scaling from 2 unsigned bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 2 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00863">863</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_acbd9313d77e392a22af0f98de90f296d_cgraph.svg" width="410" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a267e1faa2ec8371348aecddf5f384102" name="a267e1faa2ec8371348aecddf5f384102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267e1faa2ec8371348aecddf5f384102">&#9670;&#160;</a></span>int16ScaledFrom2UnsignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t int16ScaledFrom2UnsignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int16_t from a byte stream by inverse integer scaling from 2 unsigned bytes in little endian order. </p>
<p>Decode a int16_t from a byte stream by inverse integer scaling from 2 unsigned bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 2 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00879">879</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a267e1faa2ec8371348aecddf5f384102_cgraph.svg" width="407" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa40381e644eaee31ba8d6081b0e26806" name="aa40381e644eaee31ba8d6081b0e26806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40381e644eaee31ba8d6081b0e26806">&#9670;&#160;</a></span>int16ScaledFromBitfield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t int16ScaledFromBitfield </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>value</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a int16_t using inverse integer scaling from the base integer type used for bitfields. </p>
<p>Compute a int16_t using inverse integer scaling from the base integer type used for bitfields. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is the integer bitfield number to inverse scale </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be represented. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00847">847</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

</div>
</div>
<a id="a65e609acc0ff055ccc379ca1dbf807e1" name="a65e609acc0ff055ccc379ca1dbf807e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e609acc0ff055ccc379ca1dbf807e1">&#9670;&#160;</a></span>int32ScaledFrom1SignedBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t int32ScaledFrom1SignedBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int32_t from a byte stream by inverse integer scaling from 1 signed byte. </p>
<p>Decode a int32_t from a byte stream by inverse integer scaling from 1 signed byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 1 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00726">726</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

</div>
</div>
<a id="af7af078f9f85a629d6e07e5c8a785156" name="af7af078f9f85a629d6e07e5c8a785156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7af078f9f85a629d6e07e5c8a785156">&#9670;&#160;</a></span>int32ScaledFrom1UnsignedBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t int32ScaledFrom1UnsignedBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int32_t from a byte stream by inverse integer scaling from 1 unsigned byte. </p>
<p>Decode a int32_t from a byte stream by inverse integer scaling from 1 unsigned byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 1 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00711">711</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

</div>
</div>
<a id="ae439d612f4047e0841e02640487360cf" name="ae439d612f4047e0841e02640487360cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae439d612f4047e0841e02640487360cf">&#9670;&#160;</a></span>int32ScaledFrom2SignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t int32ScaledFrom2SignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int32_t from a byte stream by inverse integer scaling from 2 signed bytes in big endian order. </p>
<p>Decode a int32_t from a byte stream by inverse integer scaling from 2 signed bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 2 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00680">680</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_ae439d612f4047e0841e02640487360cf_cgraph.svg" width="402" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a169750a547c21d331230386843a674f0" name="a169750a547c21d331230386843a674f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169750a547c21d331230386843a674f0">&#9670;&#160;</a></span>int32ScaledFrom2SignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t int32ScaledFrom2SignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int32_t from a byte stream by inverse integer scaling from 2 signed bytes in little endian order. </p>
<p>Decode a int32_t from a byte stream by inverse integer scaling from 2 signed bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 2 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00695">695</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a169750a547c21d331230386843a674f0_cgraph.svg" width="398" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aaa45a5dad8692ea98f1c7621747fe7ff" name="aaa45a5dad8692ea98f1c7621747fe7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa45a5dad8692ea98f1c7621747fe7ff">&#9670;&#160;</a></span>int32ScaledFrom2UnsignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t int32ScaledFrom2UnsignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int32_t from a byte stream by inverse integer scaling from 2 unsigned bytes in big endian order. </p>
<p>Decode a int32_t from a byte stream by inverse integer scaling from 2 unsigned bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 2 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00649">649</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_aaa45a5dad8692ea98f1c7621747fe7ff_cgraph.svg" width="410" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a377fd78076c5e663dca8d1ecb87a002d" name="a377fd78076c5e663dca8d1ecb87a002d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377fd78076c5e663dca8d1ecb87a002d">&#9670;&#160;</a></span>int32ScaledFrom2UnsignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t int32ScaledFrom2UnsignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int32_t from a byte stream by inverse integer scaling from 2 unsigned bytes in little endian order. </p>
<p>Decode a int32_t from a byte stream by inverse integer scaling from 2 unsigned bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 2 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00665">665</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a377fd78076c5e663dca8d1ecb87a002d_cgraph.svg" width="407" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa4e99d9e19acab60f9e6fd52c63fb50b" name="aa4e99d9e19acab60f9e6fd52c63fb50b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e99d9e19acab60f9e6fd52c63fb50b">&#9670;&#160;</a></span>int32ScaledFrom3SignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t int32ScaledFrom3SignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int32_t from a byte stream by inverse integer scaling from 3 signed bytes in big endian order. </p>
<p>Decode a int32_t from a byte stream by inverse integer scaling from 3 signed bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 3 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00618">618</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_aa4e99d9e19acab60f9e6fd52c63fb50b_cgraph.svg" width="402" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ab30b1c178d40c6381babb1179f8a5471" name="ab30b1c178d40c6381babb1179f8a5471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30b1c178d40c6381babb1179f8a5471">&#9670;&#160;</a></span>int32ScaledFrom3SignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t int32ScaledFrom3SignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int32_t from a byte stream by inverse integer scaling from 3 signed bytes in little endian order. </p>
<p>Decode a int32_t from a byte stream by inverse integer scaling from 3 signed bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 3 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00633">633</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_ab30b1c178d40c6381babb1179f8a5471_cgraph.svg" width="398" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a12ff306b5f8cad8393198ca3ee9c5bd1" name="a12ff306b5f8cad8393198ca3ee9c5bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ff306b5f8cad8393198ca3ee9c5bd1">&#9670;&#160;</a></span>int32ScaledFrom3UnsignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t int32ScaledFrom3UnsignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int32_t from a byte stream by inverse integer scaling from 3 unsigned bytes in big endian order. </p>
<p>Decode a int32_t from a byte stream by inverse integer scaling from 3 unsigned bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 3 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00587">587</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a12ff306b5f8cad8393198ca3ee9c5bd1_cgraph.svg" width="410" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a2bc0fbffa62f8fc291827603bbd075b5" name="a2bc0fbffa62f8fc291827603bbd075b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc0fbffa62f8fc291827603bbd075b5">&#9670;&#160;</a></span>int32ScaledFrom3UnsignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t int32ScaledFrom3UnsignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int32_t from a byte stream by inverse integer scaling from 3 unsigned bytes in little endian order. </p>
<p>Decode a int32_t from a byte stream by inverse integer scaling from 3 unsigned bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 3 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00603">603</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a2bc0fbffa62f8fc291827603bbd075b5_cgraph.svg" width="407" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ab14b0957b07b56dc89be3cb26b5acec1" name="ab14b0957b07b56dc89be3cb26b5acec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14b0957b07b56dc89be3cb26b5acec1">&#9670;&#160;</a></span>int32ScaledFrom4SignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t int32ScaledFrom4SignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int32_t from a byte stream by inverse integer scaling from 4 signed bytes in big endian order. </p>
<p>Decode a int32_t from a byte stream by inverse integer scaling from 4 signed bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 4 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00556">556</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_ab14b0957b07b56dc89be3cb26b5acec1_cgraph.svg" width="402" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a73f429ff91bba10e0473a7354232b90e" name="a73f429ff91bba10e0473a7354232b90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f429ff91bba10e0473a7354232b90e">&#9670;&#160;</a></span>int32ScaledFrom4SignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t int32ScaledFrom4SignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int32_t from a byte stream by inverse integer scaling from 4 signed bytes in little endian order. </p>
<p>Decode a int32_t from a byte stream by inverse integer scaling from 4 signed bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 4 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00571">571</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a73f429ff91bba10e0473a7354232b90e_cgraph.svg" width="398" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a46bd8d4c89651965da505903fe7fd07a" name="a46bd8d4c89651965da505903fe7fd07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46bd8d4c89651965da505903fe7fd07a">&#9670;&#160;</a></span>int32ScaledFrom4UnsignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t int32ScaledFrom4UnsignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int32_t from a byte stream by inverse integer scaling from 4 unsigned bytes in big endian order. </p>
<p>Decode a int32_t from a byte stream by inverse integer scaling from 4 unsigned bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 4 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00525">525</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a46bd8d4c89651965da505903fe7fd07a_cgraph.svg" width="410" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a666183c51cc19173c37aafa06fb102d1" name="a666183c51cc19173c37aafa06fb102d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666183c51cc19173c37aafa06fb102d1">&#9670;&#160;</a></span>int32ScaledFrom4UnsignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t int32ScaledFrom4UnsignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int32_t from a byte stream by inverse integer scaling from 4 unsigned bytes in little endian order. </p>
<p>Decode a int32_t from a byte stream by inverse integer scaling from 4 unsigned bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 4 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00541">541</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a666183c51cc19173c37aafa06fb102d1_cgraph.svg" width="407" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a832596a1cf5af5ea755abee974abfc21" name="a832596a1cf5af5ea755abee974abfc21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832596a1cf5af5ea755abee974abfc21">&#9670;&#160;</a></span>int32ScaledFromBitfield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t int32ScaledFromBitfield </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>value</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a int32_t using inverse integer scaling from the base integer type used for bitfields. </p>
<p>Compute a int32_t using inverse integer scaling from the base integer type used for bitfields. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is the integer bitfield number to inverse scale </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be represented. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00509">509</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

</div>
</div>
<a id="a3880f2c4f6387b5aad0c42120d6e3457" name="a3880f2c4f6387b5aad0c42120d6e3457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3880f2c4f6387b5aad0c42120d6e3457">&#9670;&#160;</a></span>int8ScaledFrom1SignedBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t int8ScaledFrom1SignedBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int8_t from a byte stream by inverse integer scaling from 1 signed byte. </p>
<p>Decode a int8_t from a byte stream by inverse integer scaling from 1 signed byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 1 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l01030">1030</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

</div>
</div>
<a id="a3c70326a64bae37b2ed78b9f4778882e" name="a3c70326a64bae37b2ed78b9f4778882e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c70326a64bae37b2ed78b9f4778882e">&#9670;&#160;</a></span>int8ScaledFrom1UnsignedBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t int8ScaledFrom1UnsignedBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a int8_t from a byte stream by inverse integer scaling from 1 unsigned byte. </p>
<p>Decode a int8_t from a byte stream by inverse integer scaling from 1 unsigned byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 1 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l01015">1015</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

</div>
</div>
<a id="a8a4b950f840234f67713ada19d4dab8f" name="a8a4b950f840234f67713ada19d4dab8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4b950f840234f67713ada19d4dab8f">&#9670;&#160;</a></span>int8ScaledFromBitfield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t int8ScaledFromBitfield </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>value</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a int8_t using inverse integer scaling from the base integer type used for bitfields. </p>
<p>Compute a int8_t using inverse integer scaling from the base integer type used for bitfields. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is the integer bitfield number to inverse scale </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be represented. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00999">999</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

</div>
</div>
<a id="a2c8b49ff6465832c98e1558b60d93a79" name="a2c8b49ff6465832c98e1558b60d93a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8b49ff6465832c98e1558b60d93a79">&#9670;&#160;</a></span>uint16ScaledFrom1SignedBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t uint16ScaledFrom1SignedBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint16_t from a byte stream by inverse integer scaling from 1 signed byte. </p>
<p>Decode a uint16_t from a byte stream by inverse integer scaling from 1 signed byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 1 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00833">833</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

</div>
</div>
<a id="a490dddb84344fca31dcda6a306d64d48" name="a490dddb84344fca31dcda6a306d64d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490dddb84344fca31dcda6a306d64d48">&#9670;&#160;</a></span>uint16ScaledFrom1UnsignedBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t uint16ScaledFrom1UnsignedBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint16_t from a byte stream by inverse integer scaling from 1 unsigned byte. </p>
<p>Decode a uint16_t from a byte stream by inverse integer scaling from 1 unsigned byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 1 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00818">818</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

</div>
</div>
<a id="ad33bea4a8d5566a8f02fd7e6fb778ac9" name="ad33bea4a8d5566a8f02fd7e6fb778ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33bea4a8d5566a8f02fd7e6fb778ac9">&#9670;&#160;</a></span>uint16ScaledFrom2SignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t uint16ScaledFrom2SignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint16_t from a byte stream by inverse integer scaling from 2 signed bytes in big endian order. </p>
<p>Decode a uint16_t from a byte stream by inverse integer scaling from 2 signed bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 2 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00787">787</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_ad33bea4a8d5566a8f02fd7e6fb778ac9_cgraph.svg" width="410" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a2eea151e0c620113f51724fdd02c925f" name="a2eea151e0c620113f51724fdd02c925f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eea151e0c620113f51724fdd02c925f">&#9670;&#160;</a></span>uint16ScaledFrom2SignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t uint16ScaledFrom2SignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint16_t from a byte stream by inverse integer scaling from 2 signed bytes in little endian order. </p>
<p>Decode a uint16_t from a byte stream by inverse integer scaling from 2 signed bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 2 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00802">802</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a2eea151e0c620113f51724fdd02c925f_cgraph.svg" width="406" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a6a22e78b8bb9db400da4c263d9014d08" name="a6a22e78b8bb9db400da4c263d9014d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a22e78b8bb9db400da4c263d9014d08">&#9670;&#160;</a></span>uint16ScaledFrom2UnsignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t uint16ScaledFrom2UnsignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint16_t from a byte stream by inverse integer scaling from 2 unsigned bytes in big endian order. </p>
<p>Decode a uint16_t from a byte stream by inverse integer scaling from 2 unsigned bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 2 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00756">756</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a6a22e78b8bb9db400da4c263d9014d08_cgraph.svg" width="418" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ae0428820f368fff54503e56bbb87f5d8" name="ae0428820f368fff54503e56bbb87f5d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0428820f368fff54503e56bbb87f5d8">&#9670;&#160;</a></span>uint16ScaledFrom2UnsignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t uint16ScaledFrom2UnsignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint16_t from a byte stream by inverse integer scaling from 2 unsigned bytes in little endian order. </p>
<p>Decode a uint16_t from a byte stream by inverse integer scaling from 2 unsigned bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 2 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00772">772</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_ae0428820f368fff54503e56bbb87f5d8_cgraph.svg" width="415" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa0ea69be25bcf56a4c40ae99fadfe229" name="aa0ea69be25bcf56a4c40ae99fadfe229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ea69be25bcf56a4c40ae99fadfe229">&#9670;&#160;</a></span>uint16ScaledFromBitfield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t uint16ScaledFromBitfield </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>value</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a uint16_t using inverse integer scaling from the base integer type used for bitfields. </p>
<p>Compute a uint16_t using inverse integer scaling from the base integer type used for bitfields. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is the integer bitfield number to inverse scale </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be represented. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00740">740</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

</div>
</div>
<a id="a42f444bdfc74fb25028669ab06d0d58a" name="a42f444bdfc74fb25028669ab06d0d58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f444bdfc74fb25028669ab06d0d58a">&#9670;&#160;</a></span>uint32ScaledFrom1SignedBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uint32ScaledFrom1SignedBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint32_t from a byte stream by inverse integer scaling from 1 signed byte. </p>
<p>Decode a uint32_t from a byte stream by inverse integer scaling from 1 signed byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 1 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00495">495</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

</div>
</div>
<a id="aaab340ce15764448a0ed0b27bf176b3b" name="aaab340ce15764448a0ed0b27bf176b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab340ce15764448a0ed0b27bf176b3b">&#9670;&#160;</a></span>uint32ScaledFrom1UnsignedBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uint32ScaledFrom1UnsignedBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint32_t from a byte stream by inverse integer scaling from 1 unsigned byte. </p>
<p>Decode a uint32_t from a byte stream by inverse integer scaling from 1 unsigned byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 1 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00480">480</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

</div>
</div>
<a id="a3f42cf34be9ddec4b48e89723313ba99" name="a3f42cf34be9ddec4b48e89723313ba99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f42cf34be9ddec4b48e89723313ba99">&#9670;&#160;</a></span>uint32ScaledFrom2SignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uint32ScaledFrom2SignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint32_t from a byte stream by inverse integer scaling from 2 signed bytes in big endian order. </p>
<p>Decode a uint32_t from a byte stream by inverse integer scaling from 2 signed bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 2 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00449">449</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a3f42cf34be9ddec4b48e89723313ba99_cgraph.svg" width="410" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a3a30a9116ab53e21d5f20f0fd7111cf5" name="a3a30a9116ab53e21d5f20f0fd7111cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a30a9116ab53e21d5f20f0fd7111cf5">&#9670;&#160;</a></span>uint32ScaledFrom2SignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uint32ScaledFrom2SignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint32_t from a byte stream by inverse integer scaling from 2 signed bytes in little endian order. </p>
<p>Decode a uint32_t from a byte stream by inverse integer scaling from 2 signed bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 2 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00464">464</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a3a30a9116ab53e21d5f20f0fd7111cf5_cgraph.svg" width="406" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ad3e56232f27971931c4b64d16838072a" name="ad3e56232f27971931c4b64d16838072a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e56232f27971931c4b64d16838072a">&#9670;&#160;</a></span>uint32ScaledFrom2UnsignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uint32ScaledFrom2UnsignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint32_t from a byte stream by inverse integer scaling from 2 unsigned bytes in big endian order. </p>
<p>Decode a uint32_t from a byte stream by inverse integer scaling from 2 unsigned bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 2 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00418">418</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_ad3e56232f27971931c4b64d16838072a_cgraph.svg" width="418" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a0b30994eb9e0c95d982d133a5d5959b4" name="a0b30994eb9e0c95d982d133a5d5959b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b30994eb9e0c95d982d133a5d5959b4">&#9670;&#160;</a></span>uint32ScaledFrom2UnsignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uint32ScaledFrom2UnsignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint32_t from a byte stream by inverse integer scaling from 2 unsigned bytes in little endian order. </p>
<p>Decode a uint32_t from a byte stream by inverse integer scaling from 2 unsigned bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 2 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00434">434</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a0b30994eb9e0c95d982d133a5d5959b4_cgraph.svg" width="415" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ad24e8bdebc1b003a6a49101e1ab5e5ad" name="ad24e8bdebc1b003a6a49101e1ab5e5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24e8bdebc1b003a6a49101e1ab5e5ad">&#9670;&#160;</a></span>uint32ScaledFrom3SignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uint32ScaledFrom3SignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint32_t from a byte stream by inverse integer scaling from 3 signed bytes in big endian order. </p>
<p>Decode a uint32_t from a byte stream by inverse integer scaling from 3 signed bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 3 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00387">387</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_ad24e8bdebc1b003a6a49101e1ab5e5ad_cgraph.svg" width="410" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a6d24b4b107913eea939dee95f997fb82" name="a6d24b4b107913eea939dee95f997fb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d24b4b107913eea939dee95f997fb82">&#9670;&#160;</a></span>uint32ScaledFrom3SignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uint32ScaledFrom3SignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint32_t from a byte stream by inverse integer scaling from 3 signed bytes in little endian order. </p>
<p>Decode a uint32_t from a byte stream by inverse integer scaling from 3 signed bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 3 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00402">402</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a6d24b4b107913eea939dee95f997fb82_cgraph.svg" width="406" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ad7c586b3c7d1b5dffa3c49a4fe27b7eb" name="ad7c586b3c7d1b5dffa3c49a4fe27b7eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c586b3c7d1b5dffa3c49a4fe27b7eb">&#9670;&#160;</a></span>uint32ScaledFrom3UnsignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uint32ScaledFrom3UnsignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint32_t from a byte stream by inverse integer scaling from 3 unsigned bytes in big endian order. </p>
<p>Decode a uint32_t from a byte stream by inverse integer scaling from 3 unsigned bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 3 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00356">356</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_ad7c586b3c7d1b5dffa3c49a4fe27b7eb_cgraph.svg" width="418" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ad166bf409b7c902ea9dadb8eed839cfc" name="ad166bf409b7c902ea9dadb8eed839cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad166bf409b7c902ea9dadb8eed839cfc">&#9670;&#160;</a></span>uint32ScaledFrom3UnsignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uint32ScaledFrom3UnsignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint32_t from a byte stream by inverse integer scaling from 3 unsigned bytes in little endian order. </p>
<p>Decode a uint32_t from a byte stream by inverse integer scaling from 3 unsigned bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 3 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00372">372</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_ad166bf409b7c902ea9dadb8eed839cfc_cgraph.svg" width="415" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a39ba5deb606ce7e9abf6e500d7443359" name="a39ba5deb606ce7e9abf6e500d7443359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ba5deb606ce7e9abf6e500d7443359">&#9670;&#160;</a></span>uint32ScaledFrom4SignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uint32ScaledFrom4SignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint32_t from a byte stream by inverse integer scaling from 4 signed bytes in big endian order. </p>
<p>Decode a uint32_t from a byte stream by inverse integer scaling from 4 signed bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 4 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00325">325</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a39ba5deb606ce7e9abf6e500d7443359_cgraph.svg" width="410" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a04e7a55e9c4995fa94ce9b31dd710ca0" name="a04e7a55e9c4995fa94ce9b31dd710ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e7a55e9c4995fa94ce9b31dd710ca0">&#9670;&#160;</a></span>uint32ScaledFrom4SignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uint32ScaledFrom4SignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint32_t from a byte stream by inverse integer scaling from 4 signed bytes in little endian order. </p>
<p>Decode a uint32_t from a byte stream by inverse integer scaling from 4 signed bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 4 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00340">340</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_a04e7a55e9c4995fa94ce9b31dd710ca0_cgraph.svg" width="406" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="af1c44296e43e0542644aef57445d1684" name="af1c44296e43e0542644aef57445d1684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c44296e43e0542644aef57445d1684">&#9670;&#160;</a></span>uint32ScaledFrom4UnsignedBeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uint32ScaledFrom4UnsignedBeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint32_t from a byte stream by inverse integer scaling from 4 unsigned bytes in big endian order. </p>
<p>Decode a uint32_t from a byte stream by inverse integer scaling from 4 unsigned bytes in big endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 4 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00294">294</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_af1c44296e43e0542644aef57445d1684_cgraph.svg" width="418" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="abd01e92764da7f5a2169e952f5fbd85e" name="abd01e92764da7f5a2169e952f5fbd85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd01e92764da7f5a2169e952f5fbd85e">&#9670;&#160;</a></span>uint32ScaledFrom4UnsignedLeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uint32ScaledFrom4UnsignedLeBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint32_t from a byte stream by inverse integer scaling from 4 unsigned bytes in little endian order. </p>
<p>Decode a uint32_t from a byte stream by inverse integer scaling from 4 unsigned bytes in little endian order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 4 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00310">310</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="scaleddecode_8c_abd01e92764da7f5a2169e952f5fbd85e_cgraph.svg" width="415" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ad45b206060ed5c6aef8c86e240f548a9" name="ad45b206060ed5c6aef8c86e240f548a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45b206060ed5c6aef8c86e240f548a9">&#9670;&#160;</a></span>uint32ScaledFromBitfield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uint32ScaledFromBitfield </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>value</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a uint32_t using inverse integer scaling from the base integer type used for bitfields. </p>
<p>Compute a uint32_t using inverse integer scaling from the base integer type used for bitfields. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is the integer bitfield number to inverse scale </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be represented. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00278">278</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

</div>
</div>
<a id="a9600e1f5666c1afcc50a9485638331ef" name="a9600e1f5666c1afcc50a9485638331ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9600e1f5666c1afcc50a9485638331ef">&#9670;&#160;</a></span>uint8ScaledFrom1SignedBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t uint8ScaledFrom1SignedBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint8_t from a byte stream by inverse integer scaling from 1 signed byte. </p>
<p>Decode a uint8_t from a byte stream by inverse integer scaling from 1 signed byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 1 when this function is complete. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00985">985</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

</div>
</div>
<a id="a67acf1fbc9c0dc4efa929e2ecf1c3639" name="a67acf1fbc9c0dc4efa929e2ecf1c3639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67acf1fbc9c0dc4efa929e2ecf1c3639">&#9670;&#160;</a></span>uint8ScaledFrom1UnsignedBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t uint8ScaledFrom1UnsignedBytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a uint8_t from a byte stream by inverse integer scaling from 1 unsigned byte. </p>
<p>Decode a uint8_t from a byte stream by inverse integer scaling from 1 unsigned byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>is a pointer to the byte stream to decode. </td></tr>
    <tr><td class="paramname">index</td><td>gives the location of the first byte in the byte stream, and will be incremented by 1 when this function is complete. </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be decoded. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00970">970</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

</div>
</div>
<a id="a4f73c9d6f30767dc199c6dcdf3419d5a" name="a4f73c9d6f30767dc199c6dcdf3419d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f73c9d6f30767dc199c6dcdf3419d5a">&#9670;&#160;</a></span>uint8ScaledFromBitfield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t uint8ScaledFromBitfield </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>value</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a uint8_t using inverse integer scaling from the base integer type used for bitfields. </p>
<p>Compute a uint8_t using inverse integer scaling from the base integer type used for bitfields. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is the integer bitfield number to inverse scale </td></tr>
    <tr><td class="paramname">min</td><td>is the minimum value that can be represented. </td></tr>
    <tr><td class="paramname">divisor</td><td>is divided into the encoded integer to create the return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correctly scaled decoded value: return = min + encoded/divisor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scaleddecode_8c_source.html#l00954">954</a> of file <a class="el" href="scaleddecode_8c_source.html">scaleddecode.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 22 2024 16:14:17 for APM:Libraries by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
