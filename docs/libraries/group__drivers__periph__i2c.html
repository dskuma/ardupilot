<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>APM:Libraries: I2C</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">APM:Libraries
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">I2C</div></div>
</div><!--header-->
<div class="contents">

<p>Low-level I2C peripheral driver.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:i2c__sw_8c" id="r_i2c__sw_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c__sw_8c.html">i2c_sw.c</a></td></tr>
<tr class="memdesc:i2c__sw_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level I2C driver software implementation using for ESP SoCs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:i2c__sw_8h" id="r_i2c__sw_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c__sw_8h.html">i2c_sw.h</a></td></tr>
<tr class="memdesc:i2c__sw_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level I2C peripheral driver interface definition. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__i2c__bus__t.html">_i2c_bus_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gab5c0fbe837494c5f9130a5914854250d" id="r_gab5c0fbe837494c5f9130a5914854250d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab5c0fbe837494c5f9130a5914854250d">I2C_READ</a>&#160;&#160;&#160;(0x0001)</td></tr>
<tr class="memdesc:gab5c0fbe837494c5f9130a5914854250d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bit needs to be set when reading.  <br /></td></tr>
<tr class="separator:gab5c0fbe837494c5f9130a5914854250d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45fc6df6bf09a50095f509cadc0083a8" id="r_ga45fc6df6bf09a50095f509cadc0083a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga45fc6df6bf09a50095f509cadc0083a8">I2C_10BIT_MAGIC</a>&#160;&#160;&#160;(0xF0u)</td></tr>
<tr class="memdesc:ga45fc6df6bf09a50095f509cadc0083a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special bit pattern indicating a 10 bit address is used.  <br /></td></tr>
<tr class="separator:ga45fc6df6bf09a50095f509cadc0083a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga88cfeb1f124bff5994dcec3f3d793910" id="r_ga88cfeb1f124bff5994dcec3f3d793910"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga88cfeb1f124bff5994dcec3f3d793910">i2c_init</a> (<a class="el" href="struct__i2c__bus__t.html">_i2c_bus_t</a> *bus)</td></tr>
<tr class="memdesc:ga88cfeb1f124bff5994dcec3f3d793910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the given I2C bus.  <br /></td></tr>
<tr class="separator:ga88cfeb1f124bff5994dcec3f3d793910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga223edc17aeddf3e261caaca9d06e5664" id="r_ga223edc17aeddf3e261caaca9d06e5664"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga223edc17aeddf3e261caaca9d06e5664">i2c_read_reg</a> (<a class="el" href="struct__i2c__bus__t.html">_i2c_bus_t</a> *bus, uint16_t addr, uint16_t <a class="el" href="AP__InertialSensor__BMI088_8cpp.html#a9428adc9af4653a2050e2536b55dec8d">reg</a>, void *data, uint8_t flags)</td></tr>
<tr class="memdesc:ga223edc17aeddf3e261caaca9d06e5664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for reading one byte from a given register address.  <br /></td></tr>
<tr class="separator:ga223edc17aeddf3e261caaca9d06e5664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5631bfa7696e4edcb0e25b90cb2ac21" id="r_gaa5631bfa7696e4edcb0e25b90cb2ac21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa5631bfa7696e4edcb0e25b90cb2ac21">i2c_read_regs</a> (<a class="el" href="struct__i2c__bus__t.html">_i2c_bus_t</a> *bus, uint16_t addr, uint16_t <a class="el" href="AP__InertialSensor__BMI088_8cpp.html#a9428adc9af4653a2050e2536b55dec8d">reg</a>, void *data, size_t len, uint8_t flags)</td></tr>
<tr class="memdesc:gaa5631bfa7696e4edcb0e25b90cb2ac21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for reading several bytes from a given register address.  <br /></td></tr>
<tr class="separator:gaa5631bfa7696e4edcb0e25b90cb2ac21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81892c4377781abc093395752ed3209b" id="r_ga81892c4377781abc093395752ed3209b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga81892c4377781abc093395752ed3209b">i2c_read_byte</a> (<a class="el" href="struct__i2c__bus__t.html">_i2c_bus_t</a> *bus, uint16_t addr, void *data, uint8_t flags)</td></tr>
<tr class="memdesc:ga81892c4377781abc093395752ed3209b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for reading one byte from a device.  <br /></td></tr>
<tr class="separator:ga81892c4377781abc093395752ed3209b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee3ebf6dc831a91afb67f415e2684432" id="r_gaee3ebf6dc831a91afb67f415e2684432"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaee3ebf6dc831a91afb67f415e2684432">i2c_read_bytes</a> (<a class="el" href="struct__i2c__bus__t.html">_i2c_bus_t</a> *bus, uint16_t addr, void *data, size_t len, uint8_t flags)</td></tr>
<tr class="memdesc:gaee3ebf6dc831a91afb67f415e2684432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for reading bytes from a device.  <br /></td></tr>
<tr class="separator:gaee3ebf6dc831a91afb67f415e2684432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bdea58c7f2e4f08832dc6ba8f1a2be1" id="r_ga1bdea58c7f2e4f08832dc6ba8f1a2be1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1bdea58c7f2e4f08832dc6ba8f1a2be1">i2c_write_byte</a> (<a class="el" href="struct__i2c__bus__t.html">_i2c_bus_t</a> *bus, uint16_t addr, uint8_t data, uint8_t flags)</td></tr>
<tr class="memdesc:ga1bdea58c7f2e4f08832dc6ba8f1a2be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for writing a single byte onto the bus.  <br /></td></tr>
<tr class="separator:ga1bdea58c7f2e4f08832dc6ba8f1a2be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5051aa259c80b7ccda04288f44efe71f" id="r_ga5051aa259c80b7ccda04288f44efe71f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5051aa259c80b7ccda04288f44efe71f">i2c_write_bytes</a> (<a class="el" href="struct__i2c__bus__t.html">_i2c_bus_t</a> *bus, uint16_t addr, const void *data, size_t len, uint8_t flags)</td></tr>
<tr class="memdesc:ga5051aa259c80b7ccda04288f44efe71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for writing several bytes onto the bus.  <br /></td></tr>
<tr class="separator:ga5051aa259c80b7ccda04288f44efe71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8c4e544f489eb0abe0be1c3b0327cd2" id="r_gae8c4e544f489eb0abe0be1c3b0327cd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae8c4e544f489eb0abe0be1c3b0327cd2">i2c_write_reg</a> (<a class="el" href="struct__i2c__bus__t.html">_i2c_bus_t</a> *bus, uint16_t addr, uint16_t <a class="el" href="AP__InertialSensor__BMI088_8cpp.html#a9428adc9af4653a2050e2536b55dec8d">reg</a>, uint8_t data, uint8_t flags)</td></tr>
<tr class="memdesc:gae8c4e544f489eb0abe0be1c3b0327cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for writing one byte to a given register address.  <br /></td></tr>
<tr class="separator:gae8c4e544f489eb0abe0be1c3b0327cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bd61b70ce4c94bc42c6fe37fdfb5156" id="r_ga9bd61b70ce4c94bc42c6fe37fdfb5156"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9bd61b70ce4c94bc42c6fe37fdfb5156">i2c_write_regs</a> (<a class="el" href="struct__i2c__bus__t.html">_i2c_bus_t</a> *bus, uint16_t addr, uint16_t <a class="el" href="AP__InertialSensor__BMI088_8cpp.html#a9428adc9af4653a2050e2536b55dec8d">reg</a>, const void *data, size_t len, uint8_t flags)</td></tr>
<tr class="memdesc:ga9bd61b70ce4c94bc42c6fe37fdfb5156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for writing data to a given register address.  <br /></td></tr>
<tr class="separator:ga9bd61b70ce4c94bc42c6fe37fdfb5156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e6a870f98abb8cffa95373b69fb8243" id="r_ga6e6a870f98abb8cffa95373b69fb8243"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6e6a870f98abb8cffa95373b69fb8243">i2c_speed_t</a> { <br />
&#160;&#160;<a class="el" href="#gga6e6a870f98abb8cffa95373b69fb8243a6b350d376580872bb53bdfc4ff41d9b0">I2C_SPEED_LOW</a> = 0
, <a class="el" href="#gga6e6a870f98abb8cffa95373b69fb8243a0826bf5711e82ba26b4ada6104260583">I2C_SPEED_NORMAL</a>
, <a class="el" href="#gga6e6a870f98abb8cffa95373b69fb8243a8dc6cae939d20d56a78d123365caa4ca">I2C_SPEED_FAST</a>
, <a class="el" href="#gga6e6a870f98abb8cffa95373b69fb8243a42e708fe61f237d88f6cf53f32e17e8e">I2C_SPEED_FAST_PLUS</a>
, <br />
&#160;&#160;<a class="el" href="#gga6e6a870f98abb8cffa95373b69fb8243a745e792241485f11092fabd600fd6b48">I2C_SPEED_HIGH</a>
<br />
 }</td></tr>
<tr class="memdesc:ga6e6a870f98abb8cffa95373b69fb8243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default mapping of I2C bus speed values.  <a href="#ga6e6a870f98abb8cffa95373b69fb8243">More...</a><br /></td></tr>
<tr class="separator:ga6e6a870f98abb8cffa95373b69fb8243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ed58f160035134076b56c8907cf0c6b" id="r_ga9ed58f160035134076b56c8907cf0c6b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9ed58f160035134076b56c8907cf0c6b">i2c_flags_t</a> { <a class="el" href="#gga9ed58f160035134076b56c8907cf0c6ba1d95c3f463d6bbe98c1a8fbcd5d1e1f2">I2C_ADDR10</a> = 0x01
, <a class="el" href="#gga9ed58f160035134076b56c8907cf0c6ba1dc3546ab9d927d48d26781bdc4ad84e">I2C_REG16</a> = 0x02
, <a class="el" href="#gga9ed58f160035134076b56c8907cf0c6bad24d4523893d22e101e27bfc546234c3">I2C_NOSTOP</a> = 0x04
, <a class="el" href="#gga9ed58f160035134076b56c8907cf0c6bad5799291fd9b37b7cc3a381636be9c53">I2C_NOSTART</a> = 0x08
 }</td></tr>
<tr class="memdesc:ga9ed58f160035134076b56c8907cf0c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C transfer flags.  <a href="#ga9ed58f160035134076b56c8907cf0c6b">More...</a><br /></td></tr>
<tr class="separator:ga9ed58f160035134076b56c8907cf0c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c002f11842c26b1ee7048ef51bdc35b" id="r_ga8c002f11842c26b1ee7048ef51bdc35b"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a></td></tr>
<tr class="memdesc:ga8c002f11842c26b1ee7048ef51bdc35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default i2c_t type definition.  <br /></td></tr>
<tr class="separator:ga8c002f11842c26b1ee7048ef51bdc35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f14916eda80b19ff41d08e25eee56fb" id="r_ga9f14916eda80b19ff41d08e25eee56fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9f14916eda80b19ff41d08e25eee56fb">I2C_DEV</a>(<a class="el" href="DerivativeFilter_8cpp.html#a91f27329cbc70a03207bcee33e2b42fd">x</a>)&#160;&#160;&#160;(<a class="el" href="DerivativeFilter_8cpp.html#a91f27329cbc70a03207bcee33e2b42fd">x</a>)</td></tr>
<tr class="memdesc:ga9f14916eda80b19ff41d08e25eee56fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default I2C device access macro.  <br /></td></tr>
<tr class="separator:ga9f14916eda80b19ff41d08e25eee56fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad224a6eaa456b1a9682b1ca17c4aacc3" id="r_gad224a6eaa456b1a9682b1ca17c4aacc3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad224a6eaa456b1a9682b1ca17c4aacc3">I2C_UNDEF</a>&#160;&#160;&#160;(UINT_MAX)</td></tr>
<tr class="memdesc:gad224a6eaa456b1a9682b1ca17c4aacc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default I2C undefined value.  <br /></td></tr>
<tr class="separator:gad224a6eaa456b1a9682b1ca17c4aacc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Low-level I2C peripheral driver. </p>
<p>This interface provides a simple abstraction to use the MCUs I2C peripherals. It provides support for 7-bit and 10-bit addressing and can be used for different kind of register addressing schemes.</p>
<h1><a class="anchor" id="sec_i2c_usage"></a>
Usage</h1>
<p>Example for reading a 8-bit register on a device, using a 10-bit device address and 8-bit register addresses and using a RESTART condition (CAUTION: this example does not check any return values...):</p>
<div class="fragment"><div class="line"><span class="comment">// initialize the bus (this is normally done during boot time)</span></div>
<div class="line"><a class="code hl_function" href="#ga88cfeb1f124bff5994dcec3f3d793910">i2c_init</a>(<a class="code hl_variable" href="ICM20789_8cpp.html#a73e56d364aa23cb788be9693c10ef7e9">dev</a>);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// before accessing the bus, we need to acquire it</span></div>
<div class="line">i2c_acquire(<a class="code hl_variable" href="ICM20789_8cpp.html#a73e56d364aa23cb788be9693c10ef7e9">dev</a>);</div>
<div class="line"><span class="comment">// next we write the register address, but create no STOP condition when done</span></div>
<div class="line"><a class="code hl_function" href="#ga1bdea58c7f2e4f08832dc6ba8f1a2be1">i2c_write_byte</a>(<a class="code hl_variable" href="ICM20789_8cpp.html#a73e56d364aa23cb788be9693c10ef7e9">dev</a>, device_addr, reg_addr, (<a class="code hl_enumvalue" href="#gga9ed58f160035134076b56c8907cf0c6bad24d4523893d22e101e27bfc546234c3">I2C_NOSTOP</a> | <a class="code hl_enumvalue" href="#gga9ed58f160035134076b56c8907cf0c6ba1d95c3f463d6bbe98c1a8fbcd5d1e1f2">I2C_ADDR10</a>));</div>
<div class="line"><span class="comment">// and now we read the register value</span></div>
<div class="line"><a class="code hl_function" href="#ga81892c4377781abc093395752ed3209b">i2c_read_byte</a>(<a class="code hl_variable" href="ICM20789_8cpp.html#a73e56d364aa23cb788be9693c10ef7e9">dev</a>, device_addr, &amp;reg_value, <a class="code hl_enumvalue" href="#gga9ed58f160035134076b56c8907cf0c6ba1d95c3f463d6bbe98c1a8fbcd5d1e1f2">I2C_ADDR10</a>);</div>
<div class="line"><span class="comment">// finally we have to release the bus</span></div>
<div class="line">i2c_release(<a class="code hl_variable" href="ICM20789_8cpp.html#a73e56d364aa23cb788be9693c10ef7e9">dev</a>);</div>
<div class="ttc" id="aICM20789_8cpp_html_a73e56d364aa23cb788be9693c10ef7e9"><div class="ttname"><a href="ICM20789_8cpp.html#a73e56d364aa23cb788be9693c10ef7e9">dev</a></div><div class="ttdeci">static AP_HAL::OwnPtr&lt; AP_HAL::Device &gt; dev</div><div class="ttdef"><b>Definition</b> <a href="ICM20789_8cpp_source.html#l00016">ICM20789.cpp:16</a></div></div>
<div class="ttc" id="agroup__drivers__periph__i2c_html_ga1bdea58c7f2e4f08832dc6ba8f1a2be1"><div class="ttname"><a href="#ga1bdea58c7f2e4f08832dc6ba8f1a2be1">i2c_write_byte</a></div><div class="ttdeci">int i2c_write_byte(_i2c_bus_t *bus, uint16_t addr, uint8_t data, uint8_t flags)</div><div class="ttdoc">Convenience function for writing a single byte onto the bus.</div><div class="ttdef"><b>Definition</b> <a href="i2c__sw_8c_source.html#l00693">i2c_sw.c:693</a></div></div>
<div class="ttc" id="agroup__drivers__periph__i2c_html_ga81892c4377781abc093395752ed3209b"><div class="ttname"><a href="#ga81892c4377781abc093395752ed3209b">i2c_read_byte</a></div><div class="ttdeci">int i2c_read_byte(_i2c_bus_t *bus, uint16_t addr, void *data, uint8_t flags)</div><div class="ttdoc">Convenience function for reading one byte from a device.</div><div class="ttdef"><b>Definition</b> <a href="i2c__sw_8c_source.html#l00688">i2c_sw.c:688</a></div></div>
<div class="ttc" id="agroup__drivers__periph__i2c_html_ga88cfeb1f124bff5994dcec3f3d793910"><div class="ttname"><a href="#ga88cfeb1f124bff5994dcec3f3d793910">i2c_init</a></div><div class="ttdeci">void i2c_init(_i2c_bus_t *bus)</div><div class="ttdoc">Initialize the given I2C bus.</div><div class="ttdef"><b>Definition</b> <a href="i2c__sw_8c_source.html#l00113">i2c_sw.c:113</a></div></div>
<div class="ttc" id="agroup__drivers__periph__i2c_html_gga9ed58f160035134076b56c8907cf0c6ba1d95c3f463d6bbe98c1a8fbcd5d1e1f2"><div class="ttname"><a href="#gga9ed58f160035134076b56c8907cf0c6ba1d95c3f463d6bbe98c1a8fbcd5d1e1f2">I2C_ADDR10</a></div><div class="ttdeci">@ I2C_ADDR10</div><div class="ttdef"><b>Definition</b> <a href="i2c__sw_8h_source.html#l00188">i2c_sw.h:188</a></div></div>
<div class="ttc" id="agroup__drivers__periph__i2c_html_gga9ed58f160035134076b56c8907cf0c6bad24d4523893d22e101e27bfc546234c3"><div class="ttname"><a href="#gga9ed58f160035134076b56c8907cf0c6bad24d4523893d22e101e27bfc546234c3">I2C_NOSTOP</a></div><div class="ttdeci">@ I2C_NOSTOP</div><div class="ttdef"><b>Definition</b> <a href="i2c__sw_8h_source.html#l00190">i2c_sw.h:190</a></div></div>
</div><!-- fragment --><p>Example for writing a 16-bit register with 16-bit register addressing and 7-bit device addressing:</p>
<div class="fragment"><div class="line"><span class="comment">// initialize the bus</span></div>
<div class="line"><a class="code hl_function" href="#ga88cfeb1f124bff5994dcec3f3d793910">i2c_init</a>(<a class="code hl_variable" href="ICM20789_8cpp.html#a73e56d364aa23cb788be9693c10ef7e9">dev</a>);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// first, acquire the shared bus again</span></div>
<div class="line">i2c_acquire(<a class="code hl_variable" href="ICM20789_8cpp.html#a73e56d364aa23cb788be9693c10ef7e9">dev</a>);</div>
<div class="line"><span class="comment">// write the 16-bit register address to the device and prevent STOP condition</span></div>
<div class="line"><a class="code hl_function" href="#ga1bdea58c7f2e4f08832dc6ba8f1a2be1">i2c_write_byte</a>(<a class="code hl_variable" href="ICM20789_8cpp.html#a73e56d364aa23cb788be9693c10ef7e9">dev</a>, device_addr, reg_addr, <a class="code hl_enumvalue" href="#gga9ed58f160035134076b56c8907cf0c6bad24d4523893d22e101e27bfc546234c3">I2C_NOSTOP</a>);</div>
<div class="line"><span class="comment">// and write the data after a REPEATED START</span></div>
<div class="line"><a class="code hl_function" href="#ga5051aa259c80b7ccda04288f44efe71f">i2c_write_bytes</a>(<a class="code hl_variable" href="ICM20789_8cpp.html#a73e56d364aa23cb788be9693c10ef7e9">dev</a>, device_addr, reg_data, 2, 0);</div>
<div class="line"><span class="comment">// and finally free the bus again</span></div>
<div class="line">i2c_release(<a class="code hl_variable" href="ICM20789_8cpp.html#a73e56d364aa23cb788be9693c10ef7e9">dev</a>);</div>
<div class="ttc" id="agroup__drivers__periph__i2c_html_ga5051aa259c80b7ccda04288f44efe71f"><div class="ttname"><a href="#ga5051aa259c80b7ccda04288f44efe71f">i2c_write_bytes</a></div><div class="ttdeci">int IRAM_ATTR i2c_write_bytes(_i2c_bus_t *bus, uint16_t addr, const void *data, size_t len, uint8_t flags)</div><div class="ttdoc">Convenience function for writing several bytes onto the bus.</div><div class="ttdef"><b>Definition</b> <a href="i2c__sw_8c_source.html#l00220">i2c_sw.c:220</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="sec_i2c_pull"></a>
Pull Resistors</h1>
<p>The I2C signal lines SDA/SCL need external pull-up resistors which connect the lines to the positive voltage supply Vcc. The I2C driver implementation should enable the pin's internal pull-up resistors. There are however some use cases for which the internal pull resistors are not strong enough and the I2C bus will show faulty behavior. This can for example happen when connecting a logic analyzer which will raise the capacitance of the bus. In this case you should make sure you connect external pull-up resistors to both I2C bus lines.</p>
<p>The minimum and maximum resistances are computed by:  </p><p class="formulaDsp">
<picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\begin{eqnarray*}
R_{min} &amp;=&amp; \frac{V_{DD} - V_{OL(max)}} {I_{OL}}\\
R_{max} &amp;=&amp; \frac{t_r} {(0.8473 \cdot C_b)}
\end{eqnarray*}" src="form_0.png"/></picture>
</p>
<p><br  />
 where:<br  />
 <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ V_{DD} =$" src="form_1.png"/></picture> Supply voltage, <picture><source srcset="form_2_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ V_{OL(max)} =$" src="form_2.png"/></picture> Low level voltage, <picture><source srcset="form_3_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ I_{OL} =$" src="form_3.png"/></picture> Low level output current, <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ t_r =$" src="form_4.png"/></picture> Signal rise time, <picture><source srcset="form_5_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ C_b =$" src="form_5.png"/></picture> Bus capacitance <br  />
 <br  />
The pull-up resistors depend on the bus speed. Some typical values are:<br  />
 Normal mode: 10k&Omega;<br  />
 Fast mode: 2k&Omega;<br  />
 Fast plus mode: 2k&Omega;</p>
<p>For more details refer to section 7.1 in:<br  />
 <a href="http://www.nxp.com/documents/user_manual/UM10204.pdf">http://www.nxp.com/documents/user_manual/UM10204.pdf</a></p>
<h1><a class="anchor" id="sec_i2c_pm"></a>
(Low-) power implications</h1>
<p>The I2C interface realizes a transaction-based access scheme to the bus. From a power management perspective, we can leverage this by only powering on the I2C peripheral while it is actually used, that is inside an i2c_acquire() - i2c_release() block.</p>
<p>After initialization, the I2C peripheral <b>should</b> be powered off (e.g. through peripheral clock gating). It should only be powered on once a transaction on the I2C bus starts, namely in the i2c_acquire() function. Once the transaction is finished, the corresponding I2C peripheral <b>should</b> be powered off again in the i2c_release() function.</p>
<p>If the implementation puts the active thread to sleep while a transfer is in progress (e.g. when using DMA), the implementation might need to block certain power states. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga45fc6df6bf09a50095f509cadc0083a8" name="ga45fc6df6bf09a50095f509cadc0083a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45fc6df6bf09a50095f509cadc0083a8">&#9670;&#160;</a></span>I2C_10BIT_MAGIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_10BIT_MAGIC&#160;&#160;&#160;(0xF0u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special bit pattern indicating a 10 bit address is used. </p>
<p>Should only be used internally in CPU driver implementations, this is not intended to be used by applications.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.i2c-bus.org/addressing/10-bit-addressing/">https://www.i2c-bus.org/addressing/10-bit-addressing/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="i2c__sw_8h_source.html#l00168">168</a> of file <a class="el" href="i2c__sw_8h_source.html">i2c_sw.h</a>.</p>

</div>
</div>
<a id="ga9f14916eda80b19ff41d08e25eee56fb" name="ga9f14916eda80b19ff41d08e25eee56fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f14916eda80b19ff41d08e25eee56fb">&#9670;&#160;</a></span>I2C_DEV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_DEV</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><a class="el" href="DerivativeFilter_8cpp.html#a91f27329cbc70a03207bcee33e2b42fd">x</a></span></td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="DerivativeFilter_8cpp.html#a91f27329cbc70a03207bcee33e2b42fd">x</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default I2C device access macro. </p>

<p class="definition">Definition at line <a class="el" href="i2c__sw_8h_source.html#l00133">133</a> of file <a class="el" href="i2c__sw_8h_source.html">i2c_sw.h</a>.</p>

</div>
</div>
<a id="gab5c0fbe837494c5f9130a5914854250d" name="gab5c0fbe837494c5f9130a5914854250d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5c0fbe837494c5f9130a5914854250d">&#9670;&#160;</a></span>I2C_READ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_READ&#160;&#160;&#160;(0x0001)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read bit needs to be set when reading. </p>

<p class="definition">Definition at line <a class="el" href="i2c__sw_8h_source.html#l00158">158</a> of file <a class="el" href="i2c__sw_8h_source.html">i2c_sw.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="i2c__sw_8c_source.html#l00168">i2c_read_bytes()</a>.</p>

</div>
</div>
<a id="gad224a6eaa456b1a9682b1ca17c4aacc3" name="gad224a6eaa456b1a9682b1ca17c4aacc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad224a6eaa456b1a9682b1ca17c4aacc3">&#9670;&#160;</a></span>I2C_UNDEF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_UNDEF&#160;&#160;&#160;(UINT_MAX)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default I2C undefined value. </p>

<p class="definition">Definition at line <a class="el" href="i2c__sw_8h_source.html#l00142">142</a> of file <a class="el" href="i2c__sw_8h_source.html">i2c_sw.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga8c002f11842c26b1ee7048ef51bdc35b" name="ga8c002f11842c26b1ee7048ef51bdc35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c002f11842c26b1ee7048ef51bdc35b">&#9670;&#160;</a></span>i2c_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default i2c_t type definition. </p>

<p class="definition">Definition at line <a class="el" href="i2c__sw_8h_source.html#l00151">151</a> of file <a class="el" href="i2c__sw_8h_source.html">i2c_sw.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga9ed58f160035134076b56c8907cf0c6b" name="ga9ed58f160035134076b56c8907cf0c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ed58f160035134076b56c8907cf0c6b">&#9670;&#160;</a></span>i2c_flags_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga9ed58f160035134076b56c8907cf0c6b">i2c_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C transfer flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9ed58f160035134076b56c8907cf0c6ba1d95c3f463d6bbe98c1a8fbcd5d1e1f2" name="gga9ed58f160035134076b56c8907cf0c6ba1d95c3f463d6bbe98c1a8fbcd5d1e1f2"></a>I2C_ADDR10&#160;</td><td class="fielddoc"><p>use 10-bit device addressing </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9ed58f160035134076b56c8907cf0c6ba1dc3546ab9d927d48d26781bdc4ad84e" name="gga9ed58f160035134076b56c8907cf0c6ba1dc3546ab9d927d48d26781bdc4ad84e"></a>I2C_REG16&#160;</td><td class="fielddoc"><p>use 16-bit register addressing, big-endian </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9ed58f160035134076b56c8907cf0c6bad24d4523893d22e101e27bfc546234c3" name="gga9ed58f160035134076b56c8907cf0c6bad24d4523893d22e101e27bfc546234c3"></a>I2C_NOSTOP&#160;</td><td class="fielddoc"><p>do not issue a STOP condition after transfer </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9ed58f160035134076b56c8907cf0c6bad5799291fd9b37b7cc3a381636be9c53" name="gga9ed58f160035134076b56c8907cf0c6bad5799291fd9b37b7cc3a381636be9c53"></a>I2C_NOSTART&#160;</td><td class="fielddoc"><p>skip START sequence, ignores address field </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="i2c__sw_8h_source.html#l00187">187</a> of file <a class="el" href="i2c__sw_8h_source.html">i2c_sw.h</a>.</p>

</div>
</div>
<a id="ga6e6a870f98abb8cffa95373b69fb8243" name="ga6e6a870f98abb8cffa95373b69fb8243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e6a870f98abb8cffa95373b69fb8243">&#9670;&#160;</a></span>i2c_speed_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga6e6a870f98abb8cffa95373b69fb8243">i2c_speed_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default mapping of I2C bus speed values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6e6a870f98abb8cffa95373b69fb8243a6b350d376580872bb53bdfc4ff41d9b0" name="gga6e6a870f98abb8cffa95373b69fb8243a6b350d376580872bb53bdfc4ff41d9b0"></a>I2C_SPEED_LOW&#160;</td><td class="fielddoc"><p>low speed mode: ~10 kbit/s </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6e6a870f98abb8cffa95373b69fb8243a0826bf5711e82ba26b4ada6104260583" name="gga6e6a870f98abb8cffa95373b69fb8243a0826bf5711e82ba26b4ada6104260583"></a>I2C_SPEED_NORMAL&#160;</td><td class="fielddoc"><p>normal mode: ~100 kbit/s </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6e6a870f98abb8cffa95373b69fb8243a8dc6cae939d20d56a78d123365caa4ca" name="gga6e6a870f98abb8cffa95373b69fb8243a8dc6cae939d20d56a78d123365caa4ca"></a>I2C_SPEED_FAST&#160;</td><td class="fielddoc"><p>fast mode: ~400 kbit/s </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6e6a870f98abb8cffa95373b69fb8243a42e708fe61f237d88f6cf53f32e17e8e" name="gga6e6a870f98abb8cffa95373b69fb8243a42e708fe61f237d88f6cf53f32e17e8e"></a>I2C_SPEED_FAST_PLUS&#160;</td><td class="fielddoc"><p>fast plus mode: ~1000 kbit/s </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6e6a870f98abb8cffa95373b69fb8243a745e792241485f11092fabd600fd6b48" name="gga6e6a870f98abb8cffa95373b69fb8243a745e792241485f11092fabd600fd6b48"></a>I2C_SPEED_HIGH&#160;</td><td class="fielddoc"><p>high speed mode: ~3400 kbit/s </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="i2c__sw_8h_source.html#l00174">174</a> of file <a class="el" href="i2c__sw_8h_source.html">i2c_sw.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga88cfeb1f124bff5994dcec3f3d793910" name="ga88cfeb1f124bff5994dcec3f3d793910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88cfeb1f124bff5994dcec3f3d793910">&#9670;&#160;</a></span>i2c_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__i2c__bus__t.html">_i2c_bus_t</a> *</td>          <td class="paramname"><span class="paramname"><em>bus</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the given I2C bus. </p>
<p>The given I2C device will be initialized with the parameters as specified in the boards periph_conf.h, using the pins and the speed value given there.</p>
<p>The bus MUST not be acquired before initializing it, as this is handled internally by the i2c_init function!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>the device to initialize </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="i2c__sw_8c_source.html#l00113">113</a> of file <a class="el" href="i2c__sw_8c_source.html">i2c_sw.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="AP__HAL__ESP32_2I2CDevice_8cpp_source.html#l00031">ESP32::I2CDeviceManager::I2CDeviceManager()</a>, and <a class="el" href="ICM20789_8cpp_source.html#l00262">setup()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__drivers__periph__i2c_ga88cfeb1f124bff5994dcec3f3d793910_cgraph.svg" width="404" height="234"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__drivers__periph__i2c_ga88cfeb1f124bff5994dcec3f3d793910_icgraph.svg" width="322" height="102"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ga81892c4377781abc093395752ed3209b" name="ga81892c4377781abc093395752ed3209b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81892c4377781abc093395752ed3209b">&#9670;&#160;</a></span>i2c_read_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_read_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__i2c__bus__t.html">_i2c_bus_t</a> *</td>          <td class="paramname"><span class="paramname"><em>bus</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>addr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for reading one byte from a device. </p>
<dl class="section note"><dt>Note</dt><dd>This function is using a repeated start sequence for reading from the specified register address.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>i2c_acquire must be called before accessing the bus</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>I2C peripheral device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>7-bit or 10-bit device address (right-aligned) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>memory location to store received data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>optional flags (see <a class="el" href="#ga9ed58f160035134076b56c8907cf0c6b">i2c_flags_t</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 When success </dd>
<dd>
-EIO When slave device doesn't ACK the byte </dd>
<dd>
-ENXIO When no devices respond on the address sent on the bus </dd>
<dd>
-ETIMEDOUT When timeout occurs before device's response </dd>
<dd>
-EINVAL When an invalid argument is given </dd>
<dd>
-EOPNOTSUPP When MCU driver doesn't support the flag operation </dd>
<dd>
-EAGAIN When a lost bus arbitration occurs </dd></dl>

<p class="definition">Definition at line <a class="el" href="i2c__sw_8c_source.html#l00688">688</a> of file <a class="el" href="i2c__sw_8c_source.html">i2c_sw.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__drivers__periph__i2c_ga81892c4377781abc093395752ed3209b_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="gaee3ebf6dc831a91afb67f415e2684432" name="gaee3ebf6dc831a91afb67f415e2684432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee3ebf6dc831a91afb67f415e2684432">&#9670;&#160;</a></span>i2c_read_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_read_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__i2c__bus__t.html">_i2c_bus_t</a> *</td>          <td class="paramname"><span class="paramname"><em>bus</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>addr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for reading bytes from a device. </p>
<dl class="section note"><dt>Note</dt><dd>This function is using a repeated start sequence for reading from the specified register address.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>i2c_acquire must be called before accessing the bus</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>I2C peripheral device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>7-bit or 10-bit device address (right-aligned) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>memory location to store received data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>the number of bytes to read into <code>data</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>optional flags (see <a class="el" href="#ga9ed58f160035134076b56c8907cf0c6b">i2c_flags_t</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 When success </dd>
<dd>
-EIO When slave device doesn't ACK the byte </dd>
<dd>
-ENXIO When no devices respond on the address sent on the bus </dd>
<dd>
-ETIMEDOUT When timeout occurs before device's response </dd>
<dd>
-EINVAL When an invalid argument is given </dd>
<dd>
-EOPNOTSUPP When MCU driver doesn't support the flag operation </dd>
<dd>
-EAGAIN When a lost bus arbitration occurs </dd></dl>

<p class="definition">Definition at line <a class="el" href="i2c__sw_8c_source.html#l00168">168</a> of file <a class="el" href="i2c__sw_8c_source.html">i2c_sw.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="i2c__sw_8c_source.html#l00688">i2c_read_byte()</a>, <a class="el" href="i2c__sw_8c_source.html#l00657">i2c_read_regs()</a>, and <a class="el" href="AP__HAL__ESP32_2I2CDevice_8cpp_source.html#l00077">ESP32::I2CDevice::transfer()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__drivers__periph__i2c_gaee3ebf6dc831a91afb67f415e2684432_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__drivers__periph__i2c_gaee3ebf6dc831a91afb67f415e2684432_icgraph.svg" width="527" height="135"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ga223edc17aeddf3e261caaca9d06e5664" name="ga223edc17aeddf3e261caaca9d06e5664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga223edc17aeddf3e261caaca9d06e5664">&#9670;&#160;</a></span>i2c_read_reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_read_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__i2c__bus__t.html">_i2c_bus_t</a> *</td>          <td class="paramname"><span class="paramname"><em>bus</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>addr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>reg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for reading one byte from a given register address. </p>
<dl class="section note"><dt>Note</dt><dd>This function is using a repeated start sequence for reading from the specified register address.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>i2c_acquire must be called before accessing the bus</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>I2C peripheral device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>register address to read from (8- or 16-bit, right-aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>7-bit or 10-bit device address (right-aligned) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>memory location to store received data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>optional flags (see <a class="el" href="#ga9ed58f160035134076b56c8907cf0c6b">i2c_flags_t</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 When success </dd>
<dd>
-EIO When slave device doesn't ACK the byte </dd>
<dd>
-ENXIO When no devices respond on the address sent on the bus </dd>
<dd>
-ETIMEDOUT When timeout occurs before device's response </dd>
<dd>
-EINVAL When an invalid argument is given </dd>
<dd>
-EOPNOTSUPP When MCU driver doesn't support the flag operation </dd>
<dd>
-EAGAIN When a lost bus arbitration occurs </dd></dl>

<p class="definition">Definition at line <a class="el" href="i2c__sw_8c_source.html#l00681">681</a> of file <a class="el" href="i2c__sw_8c_source.html">i2c_sw.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__drivers__periph__i2c_ga223edc17aeddf3e261caaca9d06e5664_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="gaa5631bfa7696e4edcb0e25b90cb2ac21" name="gaa5631bfa7696e4edcb0e25b90cb2ac21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5631bfa7696e4edcb0e25b90cb2ac21">&#9670;&#160;</a></span>i2c_read_regs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_read_regs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__i2c__bus__t.html">_i2c_bus_t</a> *</td>          <td class="paramname"><span class="paramname"><em>bus</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>addr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>reg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for reading several bytes from a given register address. </p>
<dl class="section note"><dt>Note</dt><dd>This function is using a repeated start sequence for reading from the specified register address.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>i2c_acquire must be called before accessing the bus</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>I2C peripheral device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>register address to read from (8- or 16-bit, right-aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>7-bit or 10-bit device address (right-aligned) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>memory location to store received data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>the number of bytes to read into <code>data</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>optional flags (see <a class="el" href="#ga9ed58f160035134076b56c8907cf0c6b">i2c_flags_t</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 When success </dd>
<dd>
-EIO When slave device doesn't ACK the byte </dd>
<dd>
-ENXIO When no devices respond on the address sent on the bus </dd>
<dd>
-ETIMEDOUT When timeout occurs before device's response </dd>
<dd>
-EINVAL When an invalid argument is given </dd>
<dd>
-EOPNOTSUPP When MCU driver doesn't support the flag operation </dd>
<dd>
-EAGAIN When a lost bus arbitration occurs </dd></dl>

<p class="definition">Definition at line <a class="el" href="i2c__sw_8c_source.html#l00657">657</a> of file <a class="el" href="i2c__sw_8c_source.html">i2c_sw.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="i2c__sw_8c_source.html#l00681">i2c_read_reg()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__drivers__periph__i2c_gaa5631bfa7696e4edcb0e25b90cb2ac21_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__drivers__periph__i2c_gaa5631bfa7696e4edcb0e25b90cb2ac21_icgraph.svg" width="276" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ga1bdea58c7f2e4f08832dc6ba8f1a2be1" name="ga1bdea58c7f2e4f08832dc6ba8f1a2be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bdea58c7f2e4f08832dc6ba8f1a2be1">&#9670;&#160;</a></span>i2c_write_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_write_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__i2c__bus__t.html">_i2c_bus_t</a> *</td>          <td class="paramname"><span class="paramname"><em>bus</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>addr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for writing a single byte onto the bus. </p>
<dl class="section pre"><dt>Precondition</dt><dd>i2c_acquire must be called before accessing the bus</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>I2C peripheral device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>7-bit or 10-bit device address (right-aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>byte to write to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>optional flags (see <a class="el" href="#ga9ed58f160035134076b56c8907cf0c6b">i2c_flags_t</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 When success </dd>
<dd>
-EIO When slave device doesn't ACK the byte </dd>
<dd>
-ENXIO When no devices respond on the address sent on the bus </dd>
<dd>
-ETIMEDOUT When timeout occurs before device's response </dd>
<dd>
-EINVAL When an invalid argument is given </dd>
<dd>
-EOPNOTSUPP When MCU driver doesn't support the flag operation </dd>
<dd>
-EAGAIN When a lost bus arbitration occurs </dd></dl>

<p class="definition">Definition at line <a class="el" href="i2c__sw_8c_source.html#l00693">693</a> of file <a class="el" href="i2c__sw_8c_source.html">i2c_sw.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__drivers__periph__i2c_ga1bdea58c7f2e4f08832dc6ba8f1a2be1_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="ga5051aa259c80b7ccda04288f44efe71f" name="ga5051aa259c80b7ccda04288f44efe71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5051aa259c80b7ccda04288f44efe71f">&#9670;&#160;</a></span>i2c_write_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_write_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__i2c__bus__t.html">_i2c_bus_t</a> *</td>          <td class="paramname"><span class="paramname"><em>bus</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>addr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for writing several bytes onto the bus. </p>
<dl class="section pre"><dt>Precondition</dt><dd>i2c_acquire must be called before accessing the bus</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>I2C peripheral device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>7-bit or 10-bit device address (right-aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>array holding the bytes to write to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>the number of bytes to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>optional flags (see <a class="el" href="#ga9ed58f160035134076b56c8907cf0c6b">i2c_flags_t</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 When success </dd>
<dd>
-EIO When slave device doesn't ACK the byte </dd>
<dd>
-ENXIO When no devices respond on the address sent on the bus </dd>
<dd>
-ETIMEDOUT When timeout occurs before device's response </dd>
<dd>
-EINVAL When an invalid argument is given </dd>
<dd>
-EOPNOTSUPP When MCU driver doesn't support the flag operation </dd>
<dd>
-EAGAIN When a lost bus arbitration occurs </dd></dl>

<p class="definition">Definition at line <a class="el" href="i2c__sw_8c_source.html#l00220">220</a> of file <a class="el" href="i2c__sw_8c_source.html">i2c_sw.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="i2c__sw_8c_source.html#l00657">i2c_read_regs()</a>, <a class="el" href="i2c__sw_8c_source.html#l00693">i2c_write_byte()</a>, <a class="el" href="i2c__sw_8c_source.html#l00698">i2c_write_regs()</a>, and <a class="el" href="AP__HAL__ESP32_2I2CDevice_8cpp_source.html#l00077">ESP32::I2CDevice::transfer()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__drivers__periph__i2c_ga5051aa259c80b7ccda04288f44efe71f_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__drivers__periph__i2c_ga5051aa259c80b7ccda04288f44efe71f_icgraph.svg" width="535" height="184"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="gae8c4e544f489eb0abe0be1c3b0327cd2" name="gae8c4e544f489eb0abe0be1c3b0327cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8c4e544f489eb0abe0be1c3b0327cd2">&#9670;&#160;</a></span>i2c_write_reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_write_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__i2c__bus__t.html">_i2c_bus_t</a> *</td>          <td class="paramname"><span class="paramname"><em>bus</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>addr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>reg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for writing one byte to a given register address. </p>
<dl class="section note"><dt>Note</dt><dd>This function is using a continuous sequence for writing to the specified register address. It first writes the register then data.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>i2c_acquire must be called before accessing the bus</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>I2C peripheral device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>register address to read from (8- or 16-bit, right-aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>7-bit or 10-bit device address (right-aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>byte to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>optional flags (see <a class="el" href="#ga9ed58f160035134076b56c8907cf0c6b">i2c_flags_t</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 When success </dd>
<dd>
-EIO When slave device doesn't ACK the byte </dd>
<dd>
-ENXIO When no devices respond on the address sent on the bus </dd>
<dd>
-ETIMEDOUT When timeout occurs before device's response </dd>
<dd>
-EINVAL When an invalid argument is given </dd>
<dd>
-EOPNOTSUPP When MCU driver doesn't support the flag operation </dd>
<dd>
-EAGAIN When a lost bus arbitration occurs </dd></dl>

<p class="definition">Definition at line <a class="el" href="i2c__sw_8c_source.html#l00722">722</a> of file <a class="el" href="i2c__sw_8c_source.html">i2c_sw.c</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__drivers__periph__i2c_gae8c4e544f489eb0abe0be1c3b0327cd2_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="ga9bd61b70ce4c94bc42c6fe37fdfb5156" name="ga9bd61b70ce4c94bc42c6fe37fdfb5156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bd61b70ce4c94bc42c6fe37fdfb5156">&#9670;&#160;</a></span>i2c_write_regs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_write_regs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__i2c__bus__t.html">_i2c_bus_t</a> *</td>          <td class="paramname"><span class="paramname"><em>bus</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>addr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>reg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for writing data to a given register address. </p>
<dl class="section note"><dt>Note</dt><dd>This function is using a continuous sequence for writing to the specified register address. It first writes the register then data.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>i2c_acquire must be called before accessing the bus</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>I2C peripheral device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>register address to read from (8- or 16-bit, right-aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>7-bit or 10-bit device address (right-aligned) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>memory location to store received data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>the number of bytes to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>optional flags (see <a class="el" href="#ga9ed58f160035134076b56c8907cf0c6b">i2c_flags_t</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 When success </dd>
<dd>
-EIO When slave device doesn't ACK the byte </dd>
<dd>
-ENXIO When no devices respond on the address sent on the bus </dd>
<dd>
-ETIMEDOUT When timeout occurs before device's response </dd>
<dd>
-EINVAL When an invalid argument is given </dd>
<dd>
-EOPNOTSUPP When MCU driver doesn't support the flag operation </dd>
<dd>
-EAGAIN When a lost bus arbitration occurs </dd></dl>

<p class="definition">Definition at line <a class="el" href="i2c__sw_8c_source.html#l00698">698</a> of file <a class="el" href="i2c__sw_8c_source.html">i2c_sw.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="i2c__sw_8c_source.html#l00722">i2c_write_reg()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__drivers__periph__i2c_ga9bd61b70ce4c94bc42c6fe37fdfb5156_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__drivers__periph__i2c_ga9bd61b70ce4c94bc42c6fe37fdfb5156_icgraph.svg" width="284" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 22 2024 16:14:18 for APM:Libraries by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
